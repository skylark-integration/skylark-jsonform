{"version":3,"sources":["form-node.js"],"names":["define","types","objects","funcs","arrays","strings","langx","$","jsonform","util","formNode","this","id","key","el","formElement","schemaElement","view","children","ownerTree","parentNode","childTemplate","legendChild","arrayPath","childPos","prototype","clone","node","map","child","hasNonDefaultValue","type","value","defaultValue","find","appendChild","length","push","removeChild","remove","pop","moveValuesTo","values","getFormValues","resetValues","computeInitialValues","switchValuesWith","nodeValues","params","array","inputfield","serializeArray","each","param","escapeSelector","name","val","setChildTemplate","ignoreDefaultValues","self","nbChildren","i","formData","formDesc","tpldata","idx","getValue","returnValue","listKey","split","applyArrayPath","prefix","uniqueId","keydash","slugify","replace","prop","isString","indexOf","template","valueTemplateSettings","options","option","title","isObject","extend","isSet","getObjKey","getPreviousNumberOfItems","valueInLegend","legend","arrayValue","childNumbers","arrayDepth","depth","pos","substring","truncateToArrayDepth","max","updateArrayPath","Error","formArray","concat","checked","get","formSchema","schema","eltSchema","getSchemaKey","properties","arrayMatch","cval","_jsonform_checkboxes_as_array","match","parseInt","setObjKey","isNaN","Number","_jsonform_allowEmpty","JSON","parse","e","render","html","generate","setContent","enhance","parentEl","domRoot","nextSibling","replaceWith","before","append","updateElement","domNode","getElement","fieldtemplate","parent","prepend","k","hasOwnProperty","data","elt","escape","escapeHTML","onBeforeRender","fieldTemplate","draggable","childrenhtml","fieldHtmlClass","fieldTemplateSettings","handlers","handler","onInsert","target","onevent","onChange","bind","evt","onInput","onClick","onKeyUp","onChangeHandler","trigger","insertArrayItem","domElement","undefined","deleteArrayItem","getArrayBoundaries","minItems","maxItems","getNodeBoundaries","initialNode","schemaKey","arrayKey","boundaries","minLength","maxLength","subBoundaries","Math","min"],"mappings":"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","file":"../form-node.js","sourcesContent":["define([\r\n  \"skylark-langx-types\",\r\n  \"skylark-langx-objects\",\r\n  \"skylark-langx-funcs\",\r\n  \"skylark-langx-arrays\",\r\n  \"skylark-langx-strings\",\r\n  \"skylark-langx\",\r\n  \"skylark-jquery\",\r\n  \"./jsonform\",\r\n  \"./util\"\r\n],function(types,objects,funcs,arrays,strings,langx,$,jsonform,util){\r\n\r\n\r\n  //1686-1725\r\n  //1881-3097\r\n  /**\r\n   * Truncates the key path to the requested depth.\r\n   *\r\n   * For instance, if the key path is:\r\n   *  foo.bar[].baz.toto[].truc[].bidule\r\n   * and the requested depth is 1, the returned key will be:\r\n   *  foo.bar[].baz.toto\r\n   *\r\n   * Note the function includes the path up to the next depth level.\r\n   *\r\n   * @function\r\n   * @param {String} key The path to the key in the schema, each level being\r\n   *  separated by a dot and array items being flagged with [].\r\n   * @param {Number} depth The array depth\r\n   * @return {String} The path to the key truncated to the given depth.\r\n   */\r\n  var truncateToArrayDepth = function (key, arrayDepth) {\r\n    var depth = 0;\r\n    var pos = 0;\r\n    if (!key) return null;\r\n\r\n    if (arrayDepth > 0) {\r\n      while (depth < arrayDepth) {\r\n        pos = key.indexOf('[]', pos);\r\n        if (pos === -1) {\r\n          // Key path is not \"deep\" enough, simply return the full key\r\n          return key;\r\n        }\r\n        pos = pos + 2;\r\n        depth += 1;\r\n      }\r\n    }\r\n\r\n    // Move one step further to the right without including the final []\r\n    pos = key.indexOf('[]', pos);\r\n    if (pos === -1) return key;\r\n    else return key.substring(0, pos);\r\n  };\r\n\r\n\r\n  /**\r\n   * Represents a node in the form.\r\n   *\r\n   * Nodes that have an ID are linked to the corresponding DOM element\r\n   * when rendered\r\n   *\r\n   * Note the form element and the schema elements that gave birth to the\r\n   * node may be shared among multiple nodes (in the case of arrays).\r\n   *\r\n   * @class\r\n   */\r\n  var formNode = function () {\r\n    /**\r\n     * The node's ID (may not be set)\r\n     */\r\n    this.id = null;\r\n\r\n    /**\r\n     * The node's key path (may not be set)\r\n     */\r\n    this.key = null;\r\n\r\n    /**\r\n     * DOM element associated witht the form element.\r\n     *\r\n     * The DOM element is set when the form element is rendered.\r\n     */\r\n    this.el = null;\r\n\r\n    /**\r\n     * Link to the form element that describes the node's layout\r\n     * (note the form element is shared among nodes in arrays)\r\n     */\r\n    this.formElement = null;\r\n\r\n    /**\r\n     * Link to the schema element that describes the node's value constraints\r\n     * (note the schema element is shared among nodes in arrays)\r\n     */\r\n    this.schemaElement = null;\r\n\r\n    /**\r\n     * Pointer to the \"view\" associated with the node, typically the right\r\n     * object in jsonform.elementTypes\r\n     */\r\n    this.view = null;\r\n\r\n    /**\r\n     * Node's subtree (if one is defined)\r\n     */\r\n    this.children = [];\r\n\r\n    /**\r\n     * A pointer to the form tree the node is attached to\r\n     */\r\n    this.ownerTree = null;\r\n\r\n    /**\r\n     * A pointer to the parent node of the node in the tree\r\n     */\r\n    this.parentNode = null;\r\n\r\n    /**\r\n     * Child template for array-like nodes.\r\n     *\r\n     * The child template gets cloned to create new array items.\r\n     */\r\n    this.childTemplate = null;\r\n\r\n\r\n    /**\r\n     * Direct children of array-like containers may use the value of a\r\n     * specific input field in their subtree as legend. The link to the\r\n     * legend child is kept here and initialized in computeInitialValues\r\n     * when a child sets \"valueInLegend\"\r\n     */\r\n    this.legendChild = null;\r\n\r\n\r\n    /**\r\n     * The path of indexes that lead to the current node when the\r\n     * form element is not at the root array level.\r\n     *\r\n     * Note a form element may well be nested element and still be\r\n     * at the root array level. That's typically the case for \"fieldset\"\r\n     * elements. An array level only gets created when a form element\r\n     * is of type \"array\" (or a derivated type such as \"tabarray\").\r\n     *\r\n     * The array path of a form element linked to the foo[2].bar.baz[3].toto\r\n     * element in the submitted values is [2, 3] for instance.\r\n     *\r\n     * The array path is typically used to compute the right ID for input\r\n     * fields. It is also used to update positions when an array item is\r\n     * created, moved around or suppressed.\r\n     *\r\n     * @type {Array(Number)}\r\n     */\r\n    this.arrayPath = [];\r\n\r\n    /**\r\n     * Position of the node in the list of children of its parents\r\n     */\r\n    this.childPos = 0;\r\n  };\r\n\r\n\r\n  /**\r\n   * Clones a node\r\n   *\r\n   * @function\r\n   * @param {formNode} New parent node to attach the node to\r\n   * @return {formNode} Cloned node\r\n   */\r\n  formNode.prototype.clone = function (parentNode) {\r\n    var node = new formNode();\r\n    node.arrayPath = objects.clone(this.arrayPath);\r\n    node.ownerTree = this.ownerTree;\r\n    node.parentNode = parentNode || this.parentNode;\r\n    node.formElement = this.formElement;\r\n    node.schemaElement = this.schemaElement;\r\n    node.view = this.view;\r\n    node.children = arrays.map(this.children,function (child) { \r\n      return child.clone(node);\r\n    });\r\n    if (this.childTemplate) {\r\n      node.childTemplate = this.childTemplate.clone(node);\r\n    }\r\n    return node;\r\n  };\r\n\r\n\r\n  /**\r\n   * Returns true if the subtree that starts at the current node\r\n   * has some non empty value attached to it\r\n   */\r\n  formNode.prototype.hasNonDefaultValue = function () {\r\n\r\n    // hidden elements don't count because they could make the wrong selectfieldset element active\r\n    if (this.formElement && this.formElement.type==\"hidden\") {\r\n      return false;\r\n    }\r\n\r\n    if (this.value && !this.defaultValue) {\r\n      return true;\r\n    }\r\n    var child = this.children.find(function (child) { //_.find lwf\r\n      return child.hasNonDefaultValue();\r\n    });\r\n    return !!child;\r\n  };\r\n\r\n\r\n  /**\r\n   * Attaches a child node to the current node.\r\n   *\r\n   * The child node is appended to the end of the list.\r\n   *\r\n   * @function\r\n   * @param {formNode} node The child node to append\r\n   * @return {formNode} The inserted node (same as the one given as parameter)\r\n   */\r\n  formNode.prototype.appendChild = function (node) {\r\n    node.parentNode = this;\r\n    node.childPos = this.children.length;\r\n    this.children.push(node);\r\n    return node;\r\n  };\r\n\r\n\r\n  /**\r\n   * Removes the last child of the node.\r\n   *\r\n   * @function\r\n   */\r\n  formNode.prototype.removeChild = function () {\r\n    var child = this.children[this.children.length-1];\r\n    if (!child) return;\r\n\r\n    // Remove the child from the DOM\r\n    $(child.el).remove();\r\n\r\n    // Remove the child from the array\r\n    return this.children.pop();\r\n  };\r\n\r\n\r\n  /**\r\n   * Moves the user entered values set in the current node's subtree to the\r\n   * given node's subtree.\r\n   *\r\n   * The target node must follow the same structure as the current node\r\n   * (typically, they should have been generated from the same node template)\r\n   *\r\n   * The current node MUST be rendered in the DOM.\r\n   *\r\n   * TODO: when current node is not in the DOM, extract values from formNode.value\r\n   * properties, so that the function be available even when current node is not\r\n   * in the DOM.\r\n   *\r\n   * Moving values around allows to insert/remove array items at arbitrary\r\n   * positions.\r\n   *\r\n   * @function\r\n   * @param {formNode} node Target node.\r\n   */\r\n  formNode.prototype.moveValuesTo = function (node) {\r\n    var values = this.getFormValues(node.arrayPath);\r\n    node.resetValues();\r\n    node.computeInitialValues(values, true);\r\n  };\r\n\r\n\r\n  /**\r\n   * Switches nodes user entered values.\r\n   *\r\n   * The target node must follow the same structure as the current node\r\n   * (typically, they should have been generated from the same node template)\r\n   *\r\n   * Both nodes MUST be rendered in the DOM.\r\n   *\r\n   * TODO: update getFormValues to work even if node is not rendered, using\r\n   * formNode's \"value\" property.\r\n   *\r\n   * @function\r\n   * @param {formNode} node Target node\r\n   */\r\n  formNode.prototype.switchValuesWith = function (node) {\r\n    var values = this.getFormValues(node.arrayPath);\r\n    var nodeValues = node.getFormValues(this.arrayPath);\r\n    node.resetValues();\r\n    node.computeInitialValues(values, true);\r\n    this.resetValues();\r\n    this.computeInitialValues(nodeValues, true);\r\n  };\r\n\r\n\r\n  /**\r\n   * Resets all DOM values in the node's subtree.\r\n   *\r\n   * This operation also drops all array item nodes.\r\n   * Note values are not reset to their default values, they are rather removed!\r\n   *\r\n   * @function\r\n   */\r\n  formNode.prototype.resetValues = function () {\r\n    var params = null;\r\n    var idx = 0;\r\n\r\n    // Reset value\r\n    this.value = null;\r\n\r\n    // Propagate the array path from the parent node\r\n    // (adding the position of the child for nodes that are direct\r\n    // children of array-like nodes)\r\n    if (this.parentNode) {\r\n      this.arrayPath = objects.clone(this.parentNode.arrayPath);\r\n      if (this.parentNode.view && this.parentNode.view.array) {\r\n        this.arrayPath.push(this.childPos);\r\n      }\r\n    }\r\n    else {\r\n      this.arrayPath = [];\r\n    }\r\n\r\n    if (this.view && this.view.inputfield) {\r\n      // Simple input field, extract the value from the origin,\r\n      // set the target value and reset the origin value\r\n      params = $(':input', this.el).serializeArray();\r\n      util.each(params, function (param) {\r\n        // TODO: check this, there may exist corner cases with this approach\r\n        // (with multiple checkboxes for instance)\r\n        $('[name=\"' + util.escapeSelector(param.name) + '\"]', $(this.el)).val('');\r\n      }, this);\r\n    }\r\n    else if (this.view && this.view.array) {\r\n      // The current node is an array, drop all children\r\n      while (this.children.length > 0) {\r\n        this.removeChild();\r\n      }\r\n    }\r\n\r\n    // Recurse down the tree\r\n    util.each(this.children, function (child) {\r\n      child.resetValues();\r\n    });\r\n  };\r\n\r\n\r\n  /**\r\n   * Sets the child template node for the current node.\r\n   *\r\n   * The child template node is used to create additional children\r\n   * in an array-like form element. The template is never rendered.\r\n   *\r\n   * @function\r\n   * @param {formNode} node The child template node to set\r\n   */\r\n  formNode.prototype.setChildTemplate = function (node) {\r\n    this.childTemplate = node;\r\n    node.parentNode = this;\r\n  };\r\n\r\n\r\n  /**\r\n   * Recursively sets values to all nodes of the current subtree\r\n   * based on previously submitted values, or based on default\r\n   * values when the submitted values are not enough\r\n   *\r\n   * The function should be called once in the lifetime of a node\r\n   * in the tree. It expects its parent's arrayPath to be up to date.\r\n   *\r\n   * Three cases may arise:\r\n   * 1. if the form element is a simple input field, the value is\r\n   * extracted from previously submitted values of from default values\r\n   * defined in the schema.\r\n   * 2. if the form element is an array-like node, the child template\r\n   * is used to create as many children as possible (and at least one).\r\n   * 3. the function simply recurses down the node's subtree otherwise\r\n   * (this happens when the form element is a fieldset-like element).\r\n   *\r\n   * @function\r\n   * @param {Object} values Previously submitted values for the form\r\n   * @param {Boolean} ignoreDefaultValues Ignore default values defined in the\r\n   *  schema when set.\r\n   */\r\n  formNode.prototype.computeInitialValues = function (values, ignoreDefaultValues) {\r\n    var self = this;\r\n    var node = null;\r\n    var nbChildren = 1;\r\n    var i = 0;\r\n    var formData = this.ownerTree.formDesc.tpldata || {};\r\n\r\n    // Propagate the array path from the parent node\r\n    // (adding the position of the child for nodes that are direct\r\n    // children of array-like nodes)\r\n    if (this.parentNode) {\r\n      this.arrayPath = objects.clone(this.parentNode.arrayPath);\r\n      if (this.parentNode.view && this.parentNode.view.array) {\r\n        this.arrayPath.push(this.childPos);\r\n      }\r\n    }\r\n    else {\r\n      this.arrayPath = [];\r\n    }\r\n\r\n    // Prepare special data param \"idx\" for templated values\r\n    // (is is the index of the child in its wrapping array, starting\r\n    // at 1 since that's more human-friendly than a zero-based index)\r\n    formData.idx = (this.arrayPath.length > 0) ?\r\n      this.arrayPath[this.arrayPath.length-1] + 1 :\r\n      this.childPos + 1;\r\n\r\n    // Prepare special data param \"value\" for templated values\r\n    formData.value = '';\r\n\r\n    // Prepare special function to compute the value of another field\r\n    formData.getValue = function (key) {\r\n      if (!values) {\r\n        return '';\r\n      }\r\n      var returnValue = values;\r\n      var listKey = key.split('[].');\r\n      var i;\r\n      for (i = 0; i < listKey.length - 1; i++) {\r\n        returnValue = returnValue[listKey[i]][self.arrayPath[i]];\r\n      }\r\n      return returnValue[listKey[i]];\r\n    };\r\n\r\n    if (this.formElement) {\r\n      // Compute the ID of the field (if needed)\r\n      if (this.formElement.id) {\r\n        this.id = util.applyArrayPath(this.formElement.id, this.arrayPath);\r\n      }\r\n      else if (this.view && this.view.array) {\r\n        this.id = util.escapeSelector(this.ownerTree.formDesc.prefix) +\r\n          '-elt-counter-' + strings.uniqueId();\r\n      }\r\n      else if (this.parentNode && this.parentNode.view &&\r\n        this.parentNode.view.array) {\r\n        // Array items need an array to associate the right DOM element\r\n        // to the form node when the parent is rendered.\r\n        this.id = util.escapeSelector(this.ownerTree.formDesc.prefix) +\r\n          '-elt-counter-' + strings.uniqueId();\r\n      }\r\n      else if ((this.formElement.type === 'button') ||\r\n        (this.formElement.type === 'selectfieldset') ||\r\n        (this.formElement.type === 'question') ||\r\n        (this.formElement.type === 'buttonquestion')) {\r\n        // Buttons do need an id for \"onClick\" purpose\r\n        this.id =util.escapeSelector(this.ownerTree.formDesc.prefix) +\r\n          '-elt-counter-' + strings.uniqueId();\r\n      }\r\n\r\n      // Compute the actual key (the form element's key is index-free,\r\n      // i.e. it looks like foo[].bar.baz[].truc, so we need to apply\r\n      // the array path of the node to get foo[4].bar.baz[2].truc)\r\n      if (this.formElement.key) {\r\n        this.key = util.applyArrayPath(this.formElement.key, this.arrayPath);\r\n        this.keydash = util.slugify(this.key.replace(/\\./g, '---'));\r\n      }\r\n\r\n      // Same idea for the field's name\r\n      this.name = util.applyArrayPath(this.formElement.name, this.arrayPath);\r\n\r\n      // Consider that label values are template values and apply the\r\n      // form's data appropriately (note we also apply the array path\r\n      // although that probably doesn't make much sense for labels...)\r\n      util.each([\r\n        'title',\r\n        'legend',\r\n        'description',\r\n        'append',\r\n        'prepend',\r\n        'inlinetitle',\r\n        'helpvalue',\r\n        'value',\r\n        'disabled',\r\n        'placeholder',\r\n        'readOnly'\r\n      ],  (prop) => {\r\n        if (types.isString(this.formElement[prop])) {\r\n          if (this.formElement[prop].indexOf('{{values.') !== -1) {\r\n            // This label wants to use the value of another input field.\r\n            // Convert that construct into {{jsonform.getValue(key)}} for\r\n            // Underscore to call the appropriate function of formData\r\n            // when template gets called (note calling a function is not\r\n            // exactly Mustache-friendly but is supported by Underscore).\r\n            this[prop] = this.formElement[prop].replace(\r\n              /\\{\\{values\\.([^\\}]+)\\}\\}/g,\r\n              '{{getValue(\"$1\")}}');\r\n          }\r\n          else {\r\n            // Note applying the array path probably doesn't make any sense,\r\n            // but some geek might want to have a label \"foo[].bar[].baz\",\r\n            // with the [] replaced by the appropriate array path.\r\n            this[prop] = util.applyArrayPath(this.formElement[prop], this.arrayPath);\r\n          }\r\n          if (this[prop]) {\r\n            this[prop] = langx.template(this[prop], util.valueTemplateSettings)(formData);\r\n          }\r\n        }\r\n        else {\r\n          this[prop] = this.formElement[prop];\r\n        }\r\n      });\r\n\r\n      // Apply templating to options created with \"titleMap\" as well\r\n      if (this.formElement.options) {\r\n        this.options = arrays.map(this.formElement.options,function (option) { \r\n          var title = null;\r\n          if (types.isObject(option) && option.title) {\r\n            // See a few lines above for more details about templating\r\n            // preparation here.\r\n            if (option.title.indexOf('{{values.') !== -1) {\r\n              title = option.title.replace(\r\n                /\\{\\{values\\.([^\\}]+)\\}\\}/g,\r\n                '{{getValue(\"$1\")}}');\r\n            }\r\n            else {\r\n              title = util.applyArrayPath(option.title, self.arrayPath);\r\n            }\r\n            return objects.extend({}, option, {\r\n              value: (util.isSet(option.value) ? option.value : ''),\r\n              title: langx.template(title, util.valueTemplateSettings)(formData)\r\n            });\r\n          }\r\n          else {\r\n            return option;\r\n          }\r\n        });\r\n      }\r\n    }\r\n\r\n    if (this.view && this.view.inputfield && this.schemaElement) {\r\n      // Case 1: simple input field\r\n      if (values) {\r\n        // Form has already been submitted, use former value if defined.\r\n        // Note we won't set the field to its default value otherwise\r\n        // (since the user has already rejected it)\r\n        if (util.isSet(util.getObjKey(values, this.key))) {\r\n          this.value = util.getObjKey(values, this.key);\r\n        } else if (util.isSet(this.schemaElement['default'])) {\r\n          // the value is not provided in the values section but the\r\n          // default is set in the schemaElement (which we have)\r\n          this.value = this.schemaElement['default']\r\n          // We only apply a template if it's a string\r\n          if (typeof this.value === 'string') {\r\n            this.value = langx.template(this.value, util.valueTemplateSettings)(formData);\r\n          }\r\n\r\n        }\r\n      }\r\n      else if (!ignoreDefaultValues) {\r\n        // No previously submitted form result, use default value\r\n        // defined in the schema if it's available and not already\r\n        // defined in the form element\r\n        if (!util.isSet(this.value) && util.isSet(this.schemaElement['default'])) {\r\n          this.value = this.schemaElement['default'];\r\n          if (types.isString(this.value)) {\r\n            if (this.value.indexOf('{{values.') !== -1) {\r\n              // This label wants to use the value of another input field.\r\n              // Convert that construct into {{jsonform.getValue(key)}} for\r\n              // Underscore to call the appropriate function of formData\r\n              // when template gets called (note calling a function is not\r\n              // exactly Mustache-friendly but is supported by Underscore).\r\n              this.value = this.value.replace(\r\n                /\\{\\{values\\.([^\\}]+)\\}\\}/g,\r\n                '{{getValue(\"$1\")}}');\r\n            }\r\n            else {\r\n              // Note applying the array path probably doesn't make any sense,\r\n              // but some geek might want to have a label \"foo[].bar[].baz\",\r\n              // with the [] replaced by the appropriate array path.\r\n              this.value = util.applyArrayPath(this.value, this.arrayPath);\r\n            }\r\n            if (this.value) {\r\n              this.value = langx.template(this.value, util.valueTemplateSettings)(formData);\r\n            }\r\n          }\r\n          this.defaultValue = true;\r\n        }\r\n      }\r\n    }\r\n    else if (this.view && this.view.array) {\r\n      // Case 2: array-like node\r\n      nbChildren = 0;\r\n      if (values) {\r\n        nbChildren = this.getPreviousNumberOfItems(values, this.arrayPath);\r\n      }\r\n      // TODO: use default values at the array level when form has not been\r\n      // submitted before. Note it's not that easy because each value may\r\n      // be a complex structure that needs to be pushed down the subtree.\r\n      // The easiest way is probably to generate a \"values\" object and\r\n      // compute initial values from that object\r\n      /*\r\n      else if (this.schemaElement['default']) {\r\n        nbChildren = this.schemaElement['default'].length;\r\n      }\r\n      */\r\n      else if (nbChildren === 0) {\r\n        // If form has already been submitted with no children, the array\r\n        // needs to be rendered without children. If there are no previously\r\n        // submitted values, the array gets rendered with one empty item as\r\n        // it's more natural from a user experience perspective. That item can\r\n        // be removed with a click on the \"-\" button.\r\n        nbChildren = 1;\r\n      }\r\n      for (i = 0; i < nbChildren; i++) {\r\n        this.appendChild(this.childTemplate.clone());\r\n      }\r\n    }\r\n\r\n    // Case 3 and in any case: recurse through the list of children\r\n    util.each(this.children, function (child) {\r\n      child.computeInitialValues(values, ignoreDefaultValues);\r\n    });\r\n\r\n    // If the node's value is to be used as legend for its \"container\"\r\n    // (typically the array the node belongs to), ensure that the container\r\n    // has a direct link to the node for the corresponding tab.\r\n    if (this.formElement && this.formElement.valueInLegend) {\r\n      node = this;\r\n      while (node) {\r\n        if (node.parentNode &&\r\n          node.parentNode.view &&\r\n          node.parentNode.view.array) {\r\n          node.legendChild = this;\r\n          if (node.formElement && node.formElement.legend) {\r\n            node.legend = util.applyArrayPath(node.formElement.legend, node.arrayPath);\r\n            formData.idx = (node.arrayPath.length > 0) ?\r\n              node.arrayPath[node.arrayPath.length-1] + 1 :\r\n              node.childPos + 1;\r\n            formData.value = util.isSet(this.value) ? this.value : '';\r\n            node.legend = langx.template(node.legend, util.valueTemplateSettings)(formData);\r\n            break;\r\n          }\r\n        }\r\n        node = node.parentNode;\r\n      }\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Returns the number of items that the array node should have based on\r\n   * previously submitted values.\r\n   *\r\n   * The whole difficulty is that values may be hidden deep in the subtree\r\n   * of the node and may actually target different arrays in the JSON schema.\r\n   *\r\n   * @function\r\n   * @param {Object} values Previously submitted values\r\n   * @param {Array(Number)} arrayPath the array path we're interested in\r\n   * @return {Number} The number of items in the array\r\n   */\r\n  formNode.prototype.getPreviousNumberOfItems = function (values, arrayPath) {\r\n    var key = null;\r\n    var arrayValue = null;\r\n    var childNumbers = null;\r\n    var idx = 0;\r\n\r\n    if (!values) {\r\n      // No previously submitted values, no need to go any further\r\n      return 0;\r\n    }\r\n\r\n    if (this.view.inputfield && this.schemaElement) {\r\n      // Case 1: node is a simple input field that links to a key in the schema.\r\n      // The schema key looks typically like:\r\n      //  foo.bar[].baz.toto[].truc[].bidule\r\n      // The goal is to apply the array path and truncate the key to the last\r\n      // array we're interested in, e.g. with an arrayPath [4, 2]:\r\n      //  foo.bar[4].baz.toto[2]\r\n      key = truncateToArrayDepth(this.formElement.key, arrayPath.length);\r\n      key = util.applyArrayPath(key, arrayPath);\r\n      arrayValue = jsonform.util.getObjKey(values, key);\r\n      if (!arrayValue) {\r\n        // No key? That means this field had been left empty\r\n        // in previous submit\r\n        return 0;\r\n      }\r\n      childNumbers = arrays.map(this.children,function (child) {\r\n        return child.getPreviousNumberOfItems(values, arrayPath);\r\n      });\r\n      return util.max([util.max(childNumbers) || 0, arrayValue.length]);\r\n    }\r\n    else if (this.view.array) {\r\n      // Case 2: node is an array-like node, look for input fields\r\n      // in its child template\r\n      return this.childTemplate.getPreviousNumberOfItems(values, arrayPath);\r\n    }\r\n    else {\r\n      // Case 3: node is a leaf or a container,\r\n      // recurse through the list of children and return the maximum\r\n      // number of items found in each subtree\r\n      childNumbers = arrays.map(this.children,function (child) { \r\n        return child.getPreviousNumberOfItems(values, arrayPath);\r\n      });\r\n      return util.max(childNumbers) || 0;\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Returns the structured object that corresponds to the form values entered\r\n   * by the user for the node's subtree.\r\n   *\r\n   * The returned object follows the structure of the JSON schema that gave\r\n   * birth to the form.\r\n   *\r\n   * Obviously, the node must have been rendered before that function may\r\n   * be called.\r\n   *\r\n   * @function\r\n   * @param {Array(Number)} updateArrayPath Array path to use to pretend that\r\n   *  the entered values were actually entered for another item in an array\r\n   *  (this is used to move values around when an item is inserted/removed/moved\r\n   *  in an array)\r\n   * @return {Object} The object that follows the data schema and matches the\r\n   *  values entered by the user.\r\n   */\r\n  formNode.prototype.getFormValues = function (updateArrayPath) {\r\n    // The values object that will be returned\r\n    var values = {};\r\n\r\n    if (!this.el) {\r\n      throw new Error('formNode.getFormValues can only be called on nodes that are associated with a DOM element in the tree');\r\n    }\r\n\r\n    // Form fields values\r\n    var formArray = $(':input', this.el).serializeArray();\r\n\r\n    // Set values to false for unset checkboxes and radio buttons\r\n    // because serializeArray() ignores them\r\n    formArray = formArray.concat(\r\n      $(':input[type=checkbox]:not(:disabled):not(:checked)', this.el).map( function() {\r\n        return {\"name\": this.name, \"value\": this.checked}\r\n      }).get()\r\n    );\r\n\r\n    if (updateArrayPath) {\r\n      util.each(formArray, function (param) {\r\n        param.name = util.applyArrayPath(param.name, updateArrayPath);\r\n      });\r\n    }\r\n\r\n    // The underlying data schema\r\n    var formSchema = this.ownerTree.formDesc.schema;\r\n\r\n    for (var i = 0; i < formArray.length; i++) {\r\n      // Retrieve the key definition from the data schema\r\n      var name = formArray[i].name;\r\n      var eltSchema = util.getSchemaKey(formSchema.properties, name);\r\n      var arrayMatch = null;\r\n      var cval = null;\r\n\r\n      // Skip the input field if it's not part of the schema\r\n      if (!eltSchema) continue;\r\n\r\n      // Handle multiple checkboxes separately as the idea is to generate\r\n      // an array that contains the list of enumeration items that the user\r\n      // selected.\r\n      if (eltSchema._jsonform_checkboxes_as_array) {\r\n        arrayMatch = name.match(/\\[([0-9]*)\\]$/);\r\n        if (arrayMatch) {\r\n          name = name.replace(/\\[([0-9]*)\\]$/, '');\r\n          cval = jsonform.util.getObjKey(values, name) || [];\r\n          if (formArray[i].value === '1') {\r\n            // Value selected, push the corresponding enumeration item\r\n            // to the data result\r\n            cval.push(eltSchema['enum'][parseInt(arrayMatch[1],10)]);\r\n          }\r\n          jsonform.util.setObjKey(values, name, cval);\r\n          continue;\r\n        }\r\n      }\r\n\r\n      // Type casting\r\n      if (eltSchema.type === 'boolean') {\r\n        if (formArray[i].value === '0') {\r\n          formArray[i].value = false;\r\n        } else {\r\n          formArray[i].value = !!formArray[i].value;\r\n        }\r\n      }\r\n      if ((eltSchema.type === 'number') ||\r\n        (eltSchema.type === 'integer')) {\r\n        if (types.isString(formArray[i].value)) {\r\n          if (!formArray[i].value.length) {\r\n            formArray[i].value = null;\r\n          } else if (!isNaN(Number(formArray[i].value))) {\r\n            formArray[i].value = Number(formArray[i].value);\r\n          }\r\n        }\r\n      }\r\n      if ((eltSchema.type === 'string') &&\r\n        (formArray[i].value === '') &&\r\n        !eltSchema._jsonform_allowEmpty) {\r\n        formArray[i].value=null;\r\n      }\r\n      if ((eltSchema.type === 'object') &&\r\n        types.isString(formArray[i].value) &&\r\n        (formArray[i].value.substring(0,1) === '{')) {\r\n        try {\r\n          formArray[i].value = JSON.parse(formArray[i].value);\r\n        } catch (e) {\r\n          formArray[i].value = {};\r\n        }\r\n      }\r\n      //TODO: is this due to a serialization bug?\r\n      if ((eltSchema.type === 'object') &&\r\n        (formArray[i].value === 'null' || formArray[i].value === '')) {\r\n        formArray[i].value = null;\r\n      }\r\n\r\n      if (formArray[i].name && (formArray[i].value !== null)) {\r\n        jsonform.util.setObjKey(values, formArray[i].name, formArray[i].value);\r\n      }\r\n    }\r\n    return values;\r\n  };\r\n\r\n\r\n\r\n  /**\r\n   * Renders the node.\r\n   *\r\n   * Rendering is done in three steps: HTML generation, DOM element creation\r\n   * and insertion, and an enhance step to bind event handlers.\r\n   *\r\n   * @function\r\n   * @param {Node} el The DOM element where the node is to be rendered. The\r\n   *  node is inserted at the right position based on its \"childPos\" property.\r\n   */\r\n  formNode.prototype.render = function (el) {\r\n    var html = this.generate();\r\n    this.setContent(html, el);\r\n    this.enhance();\r\n  };\r\n\r\n\r\n  /**\r\n   * Inserts/Updates the HTML content of the node in the DOM.\r\n   *\r\n   * If the HTML is an update, the new HTML content replaces the old one.\r\n   * The new HTML content is not moved around in the DOM in particular.\r\n   *\r\n   * The HTML is inserted at the right position in its parent's DOM subtree\r\n   * otherwise (well, provided there are enough children, but that should always\r\n   * be the case).\r\n   *\r\n   * @function\r\n   * @param {string} html The HTML content to render\r\n   * @param {Node} parentEl The DOM element that is to contain the DOM node.\r\n   *  This parameter is optional (the node's parent is used otherwise) and\r\n   *  is ignored if the node to render is already in the DOM tree.\r\n   */\r\n  formNode.prototype.setContent = function (html, parentEl) {\r\n    var node = $(html);\r\n    var parentNode = parentEl ||\r\n      (this.parentNode ? this.parentNode.el : this.ownerTree.domRoot);\r\n    var nextSibling = null;\r\n\r\n    if (this.el) {\r\n      // Replace the contents of the DOM element if the node is already in the tree\r\n      $(this.el).replaceWith(node);\r\n    }\r\n    else {\r\n      // Insert the node in the DOM if it's not already there\r\n      nextSibling = $(parentNode).children().get(this.childPos);\r\n      if (nextSibling) {\r\n        $(nextSibling).before(node);\r\n      }\r\n      else {\r\n        $(parentNode).append(node);\r\n      }\r\n    }\r\n\r\n    // Save the link between the form node and the generated HTML\r\n    this.el = node;\r\n\r\n    // Update the node's subtree, extracting DOM elements that match the nodes\r\n    // from the generated HTML\r\n    this.updateElement(this.el);\r\n  };\r\n\r\n\r\n  /**\r\n   * Updates the DOM element associated with the node.\r\n   *\r\n   * Only nodes that have ID are directly associated with a DOM element.\r\n   *\r\n   * @function\r\n   */\r\n  formNode.prototype.updateElement = function (domNode) {\r\n    if (this.id) {\r\n      this.el = $('#' + util.escapeSelector(this.id), domNode).get(0);\r\n      if (this.view && this.view.getElement) {\r\n        this.el = this.view.getElement(this.el);\r\n      }\r\n      if ((this.fieldtemplate !== false) &&\r\n        this.view && this.view.fieldtemplate) {\r\n        // The field template wraps the element two or three level deep\r\n        // in the DOM tree, depending on whether there is anything prepended\r\n        // or appended to the input field\r\n        this.el = $(this.el).parent().parent();\r\n        if (this.prepend || this.prepend) {\r\n          this.el = this.el.parent();\r\n        }\r\n        this.el = this.el.get(0);\r\n      }\r\n      if (this.parentNode && this.parentNode.view &&\r\n        this.parentNode.view.childTemplate) {\r\n        // TODO: the child template may introduce more than one level,\r\n        // so the number of levels introduced should rather be exposed\r\n        // somehow in jsonform.fieldtemplate.\r\n        this.el = $(this.el).parent().get(0);\r\n      }\r\n    }\r\n\r\n    for (const k in  this.children) {\r\n       if (this.children.hasOwnProperty(k) == false) {\r\n           continue;\r\n       }\r\n       this.children[k].updateElement(this.el || domNode);\r\n   }\r\n  };\r\n\r\n\r\n  /**\r\n   * Generates the view's HTML content for the underlying model.\r\n   *\r\n   * @function\r\n   */\r\n  formNode.prototype.generate = function () {\r\n    var data = {\r\n      id: this.id,\r\n      keydash: this.keydash,\r\n      elt: this.formElement,\r\n      schema: this.schemaElement,\r\n      node: this,\r\n      value: util.isSet(this.value) ? this.value : '',\r\n      escape: strings.escapeHTML\r\n    };\r\n    var template = null;\r\n    var html = '';\r\n\r\n    // Complete the data context if needed\r\n    if (this.ownerTree.formDesc.onBeforeRender) {\r\n      this.ownerTree.formDesc.onBeforeRender(data, this);\r\n    }\r\n    if (this.view.onBeforeRender) {\r\n      this.view.onBeforeRender(data, this);\r\n    }\r\n\r\n    // Use the template that 'onBeforeRender' may have set,\r\n    // falling back to that of the form element otherwise\r\n    if (this.template) {\r\n      template = this.template;\r\n    }\r\n    else if (this.formElement && this.formElement.template) {\r\n      template = this.formElement.template;\r\n    }\r\n    else {\r\n      template = this.view.template;\r\n    }\r\n\r\n    // Wrap the view template in the generic field template\r\n    // (note the strict equality to 'false', needed as we fallback\r\n    // to the view's setting otherwise)\r\n    if ((this.fieldtemplate !== false) &&\r\n      (this.fieldtemplate || this.view.fieldtemplate)) {\r\n      template = jsonform.fieldTemplate(template);\r\n    }\r\n\r\n    // Wrap the content in the child template of its parent if necessary.\r\n    if (this.parentNode && this.parentNode.view &&\r\n      this.parentNode.view.childTemplate) {\r\n      // only allow drag of children if default or enabled\r\n      template = this.parentNode.view.childTemplate(template, (!util.isSet(this.parentNode.formElement.draggable) ? true : this.parentNode.formElement.draggable));\r\n    }\r\n\r\n    // Prepare the HTML of the children\r\n    var childrenhtml = '';\r\n    util.each(this.children, function (child) {\r\n      childrenhtml += child.generate();\r\n    });\r\n    data.children = childrenhtml;\r\n\r\n    data.fieldHtmlClass = '';\r\n    if (this.ownerTree &&\r\n        this.ownerTree.formDesc &&\r\n        this.ownerTree.formDesc.params &&\r\n        this.ownerTree.formDesc.params.fieldHtmlClass) {\r\n      data.fieldHtmlClass = this.ownerTree.formDesc.params.fieldHtmlClass;\r\n    }\r\n    if (this.formElement &&\r\n        (typeof this.formElement.fieldHtmlClass !== 'undefined')) {\r\n      data.fieldHtmlClass = this.formElement.fieldHtmlClass;\r\n    }\r\n\r\n    // Apply the HTML template\r\n    html = langx.template(template, util.fieldTemplateSettings)(data);\r\n    return html;\r\n  };\r\n\r\n\r\n  /**\r\n   * Enhances the view with additional logic, binding event handlers\r\n   * in particular.\r\n   *\r\n   * The function also runs the \"insert\" event handler of the view and\r\n   * form element if they exist (starting with that of the view)\r\n   *\r\n   * @function\r\n   */\r\n  formNode.prototype.enhance = function () {\r\n    var node = this;\r\n    var handlers = null;\r\n    var handler = null;\r\n    var formData = objects.clone(this.ownerTree.formDesc.tpldata) || {};\r\n\r\n    if (this.formElement) {\r\n      // Check the view associated with the node as it may define an \"onInsert\"\r\n      // event handler to be run right away\r\n      if (this.view.onInsert) {\r\n        this.view.onInsert({ target: $(this.el) }, this);\r\n      }\r\n\r\n      handlers = this.handlers || this.formElement.handlers;\r\n\r\n      // Trigger the \"insert\" event handler\r\n      handler = this.onInsert || this.formElement.onInsert;\r\n      if (handler) {\r\n        handler({ target: $(this.el) }, this);\r\n      }\r\n      if (handlers) {\r\n        util.each(handlers, function (handler, onevent) {\r\n          if (onevent === 'insert') {\r\n            handler({ target: $(this.el) }, this);\r\n          }\r\n        }, this);\r\n      }\r\n\r\n      // No way to register event handlers if the DOM element is unknown\r\n      // TODO: find some way to register event handlers even when this.el is not set.\r\n      if (this.el) {\r\n\r\n        // Register specific event handlers\r\n        // TODO: Add support for other event handlers\r\n        if (this.onChange)\r\n          $(this.el).bind('change', function(evt) { node.onChange(evt, node); });\r\n        if (this.view.onChange)\r\n          $(this.el).bind('change', function(evt) { node.view.onChange(evt, node); });\r\n        if (this.formElement.onChange)\r\n          $(this.el).bind('change', function(evt) { node.formElement.onChange(evt, node); });\r\n\r\n        if (this.onInput)\r\n          $(this.el).bind('input', function(evt) { node.onInput(evt, node); });\r\n        if (this.view.onInput)\r\n          $(this.el).bind('input', function(evt) { node.view.onInput(evt, node); });\r\n        if (this.formElement.onInput)\r\n          $(this.el).bind('input', function(evt) { node.formElement.onInput(evt, node); });\r\n\r\n        if (this.onClick)\r\n          $(this.el).bind('click', function(evt) { node.onClick(evt, node); });\r\n        if (this.view.onClick)\r\n          $(this.el).bind('click', function(evt) { node.view.onClick(evt, node); });\r\n        if (this.formElement.onClick)\r\n          $(this.el).bind('click', function(evt) { node.formElement.onClick(evt, node); });\r\n\r\n        if (this.onKeyUp)\r\n          $(this.el).bind('keyup', function(evt) { node.onKeyUp(evt, node); });\r\n        if (this.view.onKeyUp)\r\n          $(this.el).bind('keyup', function(evt) { node.view.onKeyUp(evt, node); });\r\n        if (this.formElement.onKeyUp)\r\n          $(this.el).bind('keyup', function(evt) { node.formElement.onKeyUp(evt, node); });\r\n\r\n        if (handlers) {\r\n          util.each(handlers, function (handler, onevent) {\r\n            if (onevent !== 'insert') {\r\n              $(this.el).bind(onevent, function(evt) { handler(evt, node); });\r\n            }\r\n          }, this);\r\n        }\r\n      }\r\n\r\n      // Auto-update legend based on the input field that's associated with it\r\n      if (this.legendChild && this.legendChild.formElement) {\r\n        var onChangeHandler = function (evt) {\r\n          if (node.formElement && node.formElement.legend && node.parentNode) {\r\n            node.legend = util.applyArrayPath(node.formElement.legend, node.arrayPath);\r\n            formData.idx = (node.arrayPath.length > 0) ?\r\n                node.arrayPath[node.arrayPath.length - 1] + 1 :\r\n                node.childPos + 1;\r\n            formData.value = $(evt.target).val();\r\n            node.legend = langx.template(node.legend, util.valueTemplateSettings)(formData);\r\n            $(node.parentNode.el).trigger('legendUpdated');\r\n          }\r\n        };\r\n        $(this.legendChild.el).bind('change', onChangeHandler);\r\n        $(this.legendChild.el).bind('keyup', onChangeHandler);\r\n      }\r\n    }\r\n\r\n    // Recurse down the tree to enhance children\r\n    util.each(this.children, function (child) {\r\n      child.enhance();\r\n    });\r\n  };\r\n\r\n\r\n\r\n  /**\r\n   * Inserts an item in the array at the requested position and renders the item.\r\n   *\r\n   * @function\r\n   * @param {Number} idx Insertion index\r\n   */\r\n  formNode.prototype.insertArrayItem = function (idx, domElement) {\r\n    var i = 0;\r\n\r\n    // Insert element at the end of the array if index is not given\r\n    if (idx === undefined) {\r\n      idx = this.children.length;\r\n    }\r\n\r\n    // Create the additional array item at the end of the list,\r\n    // using the item template created when tree was initialized\r\n    // (the call to resetValues ensures that 'arrayPath' is correctly set)\r\n    var child = this.childTemplate.clone();\r\n    this.appendChild(child);\r\n    child.resetValues();\r\n\r\n    // To create a blank array item at the requested position,\r\n    // shift values down starting at the requested position\r\n    // one to insert (note we start with the end of the array on purpose)\r\n    for (i = this.children.length-2; i >= idx; i--) {\r\n      this.children[i].moveValuesTo(this.children[i+1]);\r\n    }\r\n\r\n    // Initialize the blank node we've created with default values\r\n    this.children[idx].resetValues();\r\n    this.children[idx].computeInitialValues();\r\n\r\n    // Re-render all children that have changed\r\n    for (i = idx; i < this.children.length; i++) {\r\n      this.children[i].render(domElement);\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Remove an item from an array\r\n   *\r\n   * @function\r\n   * @param {Number} idx The index number of the item to remove\r\n   */\r\n  formNode.prototype.deleteArrayItem = function (idx) {\r\n    var i = 0;\r\n    var child = null;\r\n\r\n    // Delete last item if no index is given\r\n    if (idx === undefined) {\r\n      idx = this.children.length - 1;\r\n    }\r\n\r\n    // Move values up in the array\r\n    for (i = idx; i < this.children.length-1; i++) {\r\n      this.children[i+1].moveValuesTo(this.children[i]);\r\n      this.children[i].render();\r\n    }\r\n\r\n    // Remove the last array item from the DOM tree and from the form tree\r\n    this.removeChild();\r\n  };\r\n\r\n  /**\r\n   * Returns the minimum/maximum number of items that an array field\r\n   * is allowed to have according to the schema definition of the fields\r\n   * it contains.\r\n   *\r\n   * The function parses the schema definitions of the array items that\r\n   * compose the current \"array\" node and returns the minimum value of\r\n   * \"maxItems\" it encounters as the maximum number of items, and the\r\n   * maximum value of \"minItems\" as the minimum number of items.\r\n   *\r\n   * The function reports a -1 for either of the boundaries if the schema\r\n   * does not put any constraint on the number of elements the current\r\n   * array may have of if the current node is not an array.\r\n   *\r\n   * Note that array boundaries should be defined in the JSON Schema using\r\n   * \"minItems\" and \"maxItems\". The code also supports \"minLength\" and\r\n   * \"maxLength\" as a fallback, mostly because it used to by mistake (see #22)\r\n   * and because other people could make the same mistake.\r\n   *\r\n   * @function\r\n   * @return {Object} An object with properties \"minItems\" and \"maxItems\"\r\n   *  that reports the corresponding number of items that the array may\r\n   *  have (value is -1 when there is no constraint for that boundary)\r\n   */\r\n  formNode.prototype.getArrayBoundaries = function () {\r\n    var boundaries = {\r\n      minItems: -1,\r\n      maxItems: -1\r\n    };\r\n    if (!this.view || !this.view.array) return boundaries;\r\n\r\n    var getNodeBoundaries = function (node, initialNode) {\r\n      var schemaKey = null;\r\n      var arrayKey = null;\r\n      var boundaries = {\r\n        minItems: -1,\r\n        maxItems: -1\r\n      };\r\n      initialNode = initialNode || node;\r\n\r\n      if (node.view && node.view.array && (node !== initialNode)) {\r\n        // New array level not linked to an array in the schema,\r\n        // so no size constraints\r\n        return boundaries;\r\n      }\r\n\r\n      if (node.key) {\r\n        // Note the conversion to target the actual array definition in the\r\n        // schema where minItems/maxItems may be defined. If we're still looking\r\n        // at the initial node, the goal is to convert from:\r\n        //  foo[0].bar[3].baz to foo[].bar[].baz\r\n        // If we're not looking at the initial node, the goal is to look at the\r\n        // closest array parent:\r\n        //  foo[0].bar[3].baz to foo[].bar\r\n        arrayKey = node.key.replace(/\\[[0-9]+\\]/g, '[]');\r\n        if (node !== initialNode) {\r\n          arrayKey = arrayKey.replace(/\\[\\][^\\[\\]]*$/, '');\r\n        }\r\n        schemaKey = util.getSchemaKey(\r\n          node.ownerTree.formDesc.schema.properties,\r\n          arrayKey\r\n        );\r\n        if (!schemaKey) return boundaries;\r\n        return {\r\n          minItems: schemaKey.minItems || schemaKey.minLength || -1,\r\n          maxItems: schemaKey.maxItems || schemaKey.maxLength || -1\r\n        };\r\n      }\r\n      else {\r\n        util.each(node.children, function (child) {\r\n          var subBoundaries = getNodeBoundaries(child, initialNode);\r\n          if (subBoundaries.minItems !== -1) {\r\n            if (boundaries.minItems !== -1) {\r\n              boundaries.minItems = Math.max(\r\n                boundaries.minItems,\r\n                subBoundaries.minItems\r\n              );\r\n            }\r\n            else {\r\n              boundaries.minItems = subBoundaries.minItems;\r\n            }\r\n          }\r\n          if (subBoundaries.maxItems !== -1) {\r\n            if (boundaries.maxItems !== -1) {\r\n              boundaries.maxItems = Math.min(\r\n                boundaries.maxItems,\r\n                subBoundaries.maxItems\r\n              );\r\n            }\r\n            else {\r\n              boundaries.maxItems = subBoundaries.maxItems;\r\n            }\r\n          }\r\n        });\r\n      }\r\n      return boundaries;\r\n    };\r\n    return getNodeBoundaries(this);\r\n  };\r\n\r\n  return jsonform.formNode = formNode;\r\n});\r\n\r\n"]}