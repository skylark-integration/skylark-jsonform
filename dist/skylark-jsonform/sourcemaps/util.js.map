{"version":3,"sources":["util.js"],"names":["define","langx","jsonform","reArray","isSet","value","isUndefined","isNull","util","fieldTemplateSettings","evaluate","interpolate","valueTemplateSettings","each","arrays","fn","hasOwnProperty","obj","prop","escapeSelector","selector","replace","slugify","str","applyArrayPath","key","arrayPath","depth","length","p1","newIndex","getObjKey","ignoreArrays","innerobj","keyparts","split","subkey","arrayMatch","i","lastIndex","exec","isArray","parseInt","setObjKey","getSchemaKey","schema","schemaKey","schemaDef","$ref","Error","max","arr","reduce","a","b","Math"],"mappings":"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","file":"../util.js","sourcesContent":["define([\r\n  \"skylark-langx\",\r\n  \"./jsonform\"\r\n],function(langx,jsonform){\r\n\r\n  //1519-1653\r\n  //1656-1684\r\n  //1725-1775\r\n\r\n    /**\r\n   * Regular expressions used to extract array indexes in input field names\r\n   */\r\n  var reArray = /\\[([0-9]*)\\](?=\\[|\\.|$)/g;\r\n\r\n    /**\r\n     * Template settings for form views\r\n     */\r\n    var fieldTemplateSettings = {\r\n      evaluate    : /<%([\\s\\S]+?)%>/g,\r\n      interpolate : /<%=([\\s\\S]+?)%>/g\r\n    };\r\n\r\n    /**\r\n     * Template settings for value replacement\r\n     */\r\n    var valueTemplateSettings = {\r\n      evaluate    : /\\{\\[([\\s\\S]+?)\\]\\}/g,\r\n      interpolate : /\\{\\{([\\s\\S]+?)\\}\\}/g\r\n    };\r\n\r\n\r\n    /**\r\n     * Returns true if given property is directly property of an object\r\n     */\r\n    var hasOwnProperty = function (obj, prop) {\r\n      return typeof obj === 'object' && obj.hasOwnProperty(prop);\r\n    }\r\n\r\n  /**\r\n   * Escapes selector name for use with jQuery\r\n   *\r\n   * All meta-characters listed in jQuery doc are escaped:\r\n   * http://api.jquery.com/category/selectors/\r\n   *\r\n   * @function\r\n   * @param {String} selector The jQuery selector to escape\r\n   * @return {String} The escaped selector.\r\n   */\r\n  var escapeSelector = function (selector) {\r\n    return selector.replace(/([ \\!\\\"\\#\\$\\%\\&\\'\\(\\)\\*\\+\\,\\.\\/\\:\\;<\\=\\>\\?\\@\\[\\\\\\]\\^\\`\\{\\|\\}\\~])/g, '\\\\$1');\r\n  };\r\n\r\n  /**\r\n   *\r\n   * Slugifies a string by replacing spaces with _. Used to create\r\n   * valid classnames and ids for the form.\r\n   *\r\n   * @function\r\n   * @param {String} str The string to slugify\r\n   * @return {String} The slugified string.\r\n   */\r\n  var slugify = function(str) {\r\n    return str.replace(/\\ /g, '_');\r\n  }\r\n\r\n\r\n  /**\r\n   * Returns true if given value is neither \"undefined\" nor null\r\n   */\r\n  var isSet = function (value) {\r\n    return !(langx.isUndefined(value) || langx.isNull(value));\r\n  };\r\n\r\n\r\n\r\n  //Allow to access subproperties by splitting \".\"\r\n  /**\r\n   * Retrieves the key identified by a path selector in the structured object.\r\n   *\r\n   * Levels in the path are separated by a dot. Array items are marked\r\n   * with [x]. For instance:\r\n   *  foo.bar[3].baz\r\n   *\r\n   * @function\r\n   * @param {Object} obj Structured object to parse\r\n   * @param {String} key Path to the key to retrieve\r\n   * @param {boolean} ignoreArrays True to use first element in an array when\r\n   *   stucked on a property. This parameter is basically only useful when\r\n   *   parsing a JSON schema for which the \"items\" property may either be an\r\n   *   object or an array with one object (only one because JSON form does not\r\n   *   support mix of items for arrays).\r\n   * @return {Object} The key's value.\r\n   */\r\n  var getObjKey = function (obj, key, ignoreArrays) {\r\n    var innerobj = obj;\r\n    var keyparts = key.split(\".\");\r\n    var subkey = null;\r\n    var arrayMatch = null;\r\n    var prop = null;\r\n\r\n    for (var i = 0; i < keyparts.length; i++) {\r\n      if ((innerobj === null) || (typeof innerobj !== \"object\")) return null;\r\n      subkey = keyparts[i];\r\n      prop = subkey.replace(reArray, '');\r\n      reArray.lastIndex = 0;\r\n      arrayMatch = reArray.exec(subkey);\r\n      if (arrayMatch) {\r\n        while (true) {\r\n          if (prop && !langx.isArray(innerobj[prop])) return null;\r\n          innerobj = prop ? innerobj[prop][parseInt(arrayMatch[1])] : innerobj[parseInt(arrayMatch[1])];\r\n          arrayMatch = reArray.exec(subkey);\r\n          if (!arrayMatch) break;\r\n          // In the case of multidimensional arrays,\r\n          // we should not take innerobj[prop][0] anymore,\r\n          // but innerobj[0] directly\r\n          prop = null;\r\n        }\r\n      } else if (ignoreArrays &&\r\n          !innerobj[prop] &&\r\n          langx.isArray(innerobj) &&\r\n          innerobj[0]) {\r\n        innerobj = innerobj[0][prop];\r\n      } else {\r\n        innerobj = innerobj[prop];\r\n      }\r\n    }\r\n\r\n    if (ignoreArrays && langx.isArray(innerobj) && innerobj[0]) {\r\n      return innerobj[0];\r\n    } else {\r\n      return innerobj;\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Sets the key identified by a path selector to the given value.\r\n   *\r\n   * Levels in the path are separated by a dot. Array items are marked\r\n   * with [x]. For instance:\r\n   *  foo.bar[3].baz\r\n   *\r\n   * The hierarchy is automatically created if it does not exist yet.\r\n   *\r\n   * @function\r\n   * @param {Object} obj The object to build\r\n   * @param {String} key The path to the key to set where each level\r\n   *  is separated by a dot, and array items are flagged with [x].\r\n   * @param {Object} value The value to set, may be of any type.\r\n   */\r\n  var setObjKey = function(obj,key,value) {\r\n    var innerobj = obj;\r\n    var keyparts = key.split(\".\");\r\n    var subkey = null;\r\n    var arrayMatch = null;\r\n    var prop = null;\r\n\r\n    for (var i = 0; i < keyparts.length-1; i++) {\r\n      subkey = keyparts[i];\r\n      prop = subkey.replace(reArray, '');\r\n      reArray.lastIndex = 0;\r\n      arrayMatch = reArray.exec(subkey);\r\n      if (arrayMatch) {\r\n        // Subkey is part of an array\r\n        while (true) {\r\n          if (!langx.isArray(innerobj[prop])) {\r\n            innerobj[prop] = [];\r\n          }\r\n          innerobj = innerobj[prop];\r\n          prop = parseInt(arrayMatch[1], 10);\r\n          arrayMatch = reArray.exec(subkey);\r\n          if (!arrayMatch) break;\r\n        }\r\n        if ((typeof innerobj[prop] !== 'object') ||\r\n          (innerobj[prop] === null)) {\r\n          innerobj[prop] = {};\r\n        }\r\n        innerobj = innerobj[prop];\r\n      }\r\n      else {\r\n        // \"Normal\" subkey\r\n        if ((typeof innerobj[prop] !== 'object') ||\r\n          (innerobj[prop] === null)) {\r\n          innerobj[prop] = {};\r\n        }\r\n        innerobj = innerobj[prop];\r\n      }\r\n    }\r\n\r\n    // Set the final value\r\n    subkey = keyparts[keyparts.length - 1];\r\n    prop = subkey.replace(reArray, '');\r\n    reArray.lastIndex = 0;\r\n    arrayMatch = reArray.exec(subkey);\r\n    if (arrayMatch) {\r\n      while (true) {\r\n        if (!langx.isArray(innerobj[prop])) {\r\n          innerobj[prop] = [];\r\n        }\r\n        innerobj = innerobj[prop];\r\n        prop = parseInt(arrayMatch[1], 10);\r\n        arrayMatch = reArray.exec(subkey);\r\n        if (!arrayMatch) break;\r\n      }\r\n      innerobj[prop] = value;\r\n    }\r\n    else {\r\n      innerobj[prop] = value;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Retrieves the key definition from the given schema.\r\n   *\r\n   * The key is identified by the path that leads to the key in the\r\n   * structured object that the schema would generate. Each level is\r\n   * separated by a '.'. Array levels are marked with []. For instance:\r\n   *  foo.bar[].baz\r\n   * ... to retrieve the definition of the key at the following location\r\n   * in the JSON schema (using a dotted path notation):\r\n   *  foo.properties.bar.items.properties.baz\r\n   *\r\n   * @function\r\n   * @param {Object} schema The JSON schema to retrieve the key from\r\n   * @param {String} key The path to the key, each level being separated\r\n   *  by a dot and array items being flagged with [].\r\n   * @return {Object} The key definition in the schema, null if not found.\r\n   */\r\n  var getSchemaKey = function(schema,key) {\r\n    var schemaKey = key\r\n      .replace(/\\./g, '.properties.')\r\n      .replace(/\\[[0-9]*\\]/g, '.items');\r\n    var schemaDef = jsonform.util.getObjKey(schema, schemaKey, true);\r\n    if (schemaDef && schemaDef.$ref) {\r\n      throw new Error('JSONForm does not yet support schemas that use the ' +\r\n        '$ref keyword. See: https://github.com/joshfire/jsonform/issues/54');\r\n    }\r\n    return schemaDef;\r\n  };\r\n\r\n\r\n  /**\r\n   * Applies the array path to the key path.\r\n   *\r\n   * For instance, if the key path is:\r\n   *  foo.bar[].baz.toto[].truc[].bidule\r\n   * and the arrayPath [4, 2], the returned key will be:\r\n   *  foo.bar[4].baz.toto[2].truc[].bidule\r\n   *\r\n   * @function\r\n   * @param {String} key The path to the key in the schema, each level being\r\n   *  separated by a dot and array items being flagged with [].\r\n   * @param {Array(Number)} arrayPath The array path to apply, e.g. [4, 2]\r\n   * @return {String} The path to the key that matches the array path.\r\n   */\r\n  var applyArrayPath = function (key, arrayPath) {\r\n    var depth = 0;\r\n    if (!key) return null;\r\n    if (!arrayPath || (arrayPath.length === 0)) return key;\r\n    var newKey = key.replace(reArray, function (str, p1) {\r\n      // Note this function gets called as many times as there are [x] in the ID,\r\n      // from left to right in the string. The goal is to replace the [x] with\r\n      // the appropriate index in the new array path, if defined.\r\n      var newIndex = str;\r\n      if (isSet(arrayPath[depth])) {\r\n        newIndex = '[' + arrayPath[depth] + ']';\r\n      }\r\n      depth += 1;\r\n      return newIndex;\r\n    });\r\n    return newKey;\r\n  };\r\n\r\n  var max = function(arr) {\r\n    return arr.reduce(function(a, b) {\r\n      return Math.max(a, b);\r\n    });\r\n  };\r\n\r\n  function each(arrays,fn) {\r\n    return langx.each(arrays,fn,true);\r\n  }\r\n\r\n  return jsonform.util = {\r\n    fieldTemplateSettings,\r\n    valueTemplateSettings,\r\n    each,\r\n    hasOwnProperty,\r\n    escapeSelector,\r\n    slugify,\r\n    isSet,\r\n    applyArrayPath,\r\n    getObjKey,\r\n    setObjKey,\r\n    getSchemaKey,\r\n    max\r\n  };\r\n\r\n});\r\n"]}