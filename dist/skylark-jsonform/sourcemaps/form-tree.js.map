{"version":3,"sources":["form-tree.js"],"names":["define","globals","types","objects","arrays","strings","$","jsonform","util","elementTypes","formNode","formTree","this","eventhandlers","root","formDesc","prototype","initialize","clone","prefix","uniqueId","schema","properties","form","type","items","value","isArray","params","ownerTree","view","buildTree","computeInitialValues","each","formElement","element","key","appendChild","buildFromLayout","isString","context","schemaElement","node","map","getSchemaKey","Error","onElementSchema","name","title","description","readOnly","readonly","id","escapeSelector","slugify","allowEmpty","_jsonform_allowEmpty","contains","without","required","length","first","format","isUndefined","step","options","titleMap","hasOwnProperty","itemsEnum","_jsonform_checkboxes_as_array","prop","propName","inputfield","array","iddot","handlers","setChildTemplate","item","render","domRoot","hasRequiredField","addClass","forEachElement","callback","f","i","children","validate","noErrorDisplay","values","getFormValue","errors","validator","JSONFormValidator","createEnvironment","v","jsonFormErrors","concat","displayErrors","submit","evt","stopEvent","preventDefault","stopPropagation","brk","elt","onSubmit","validated","onSubmitValid","parseElement","find","property"],"mappings":";;;;;;;AAAAA,QACE,wBACA,sBACA,wBACA,uBACA,wBACA,iBACA,aACA,SACA,kBACA,eACA,SAASC,EAAQC,EAAMC,EAAQC,EAAOC,EAAQC,EAAEC,EAASC,EAAKC,EAAaC,GAY3E,IAAIC,EAAW,WACbC,KAAKC,iBACLD,KAAKE,KAAO,KACZF,KAAKG,SAAW,MA2hBlB,OAxgBAJ,EAASK,UAAUC,WAAa,SAAUF,GACxCA,EAAWA,MAIXH,KAAKG,SAAWZ,EAAQe,MAAMH,GAE9BH,KAAKG,SAASI,OAASP,KAAKG,SAASI,QACnC,YAAcd,EAAQe,WAGpBR,KAAKG,SAASM,SAAWT,KAAKG,SAASM,OAAOC,aAChDV,KAAKG,SAASM,QACZC,WAAYV,KAAKG,SAASM,SAK9BT,KAAKG,SAASQ,KAAOX,KAAKG,SAASQ,OACjC,KAEEC,KAAM,UACNC,QAEID,KAAM,SACNE,MAAO,aAKfd,KAAKG,SAASQ,KAAQrB,EAAMyB,QAAQf,KAAKG,SAASQ,MAChDX,KAAKG,SAASQ,MACbX,KAAKG,SAASQ,MAEjBX,KAAKG,SAASa,OAAShB,KAAKG,SAASa,WAGrChB,KAAKE,KAAO,IAAIJ,EAChBE,KAAKE,KAAKe,UAAYjB,KACtBA,KAAKE,KAAKgB,KAAOrB,EAAmB,KAGpCG,KAAKmB,YAILnB,KAAKoB,wBAWPrB,EAASK,UAAUe,UAAY,WAK7BvB,EAAKyB,KAAKrB,KAAKG,SAASQ,KAAQW,IACV,MAAhBA,EACF1B,EAAKyB,KAAKrB,KAAKG,SAASM,OAAOC,WAAa,CAACa,EAASC,KACpDxB,KAAKE,KAAKuB,YAAYzB,KAAK0B,iBACzBF,IAAKA,QAKLlC,EAAMqC,SAASL,KACjBA,GACEE,IAAKF,IAGTtB,KAAKE,KAAKuB,YAAYzB,KAAK0B,gBAAgBJ,MAE5CtB,OAgBLD,EAASK,UAAUsB,gBAAkB,SAAUJ,EAAaM,GAC1D,IAEIV,EAFAW,EAAgB,KAChBC,EAAO,IAAIhC,EAEX0B,EAAM,KAiBV,IAVAF,EAAc/B,EAAQe,MAAMgB,IACZT,QACVvB,EAAMyB,QAAQO,EAAYT,OAC5BS,EAAYT,MAAQrB,EAAOuC,IAAIT,EAAYT,MAAMtB,EAAQe,OAGzDgB,EAAYT,OAAUtB,EAAQe,MAAMgB,EAAYT,SAIhDS,EAAYE,IAAK,CAUnB,KAHAK,EAAgBjC,EAAKoC,aACnBhC,KAAKG,SAASM,OAAOC,WACrBY,EAAYE,MAGZ,MAAM,IAAIS,MAAM,kDACdX,EAAYE,IAAM,oDAwCtB,GAjCIxB,KAAKG,SAAS+B,iBAChBlC,KAAKG,SAAS+B,gBAAgBZ,EAAaO,GAG7CP,EAAYa,KACVb,EAAYa,MACZb,EAAYE,IACdF,EAAYc,MACVd,EAAYc,OACZP,EAAcO,MAChBd,EAAYe,YACVf,EAAYe,aACZR,EAAcQ,YAChBf,EAAYgB,SACVhB,EAAYgB,UACZT,EAAcS,UACdhB,EAAYiB,UACZV,EAAcU,SAGXjB,EAAYkB,KACflB,EAAYkB,GAAK5C,EAAK6C,eAAezC,KAAKG,SAASI,QACjD,QAAUX,EAAK8C,QAAQpB,EAAYE,MAKnCF,EAAYqB,aACdd,EAAce,sBAAuB,IAKlCtB,EAAYV,KAAM,CAGrB,GAAItB,EAAMyB,QAAQc,EAAcjB,MAAO,CAKrC,GAJIpB,EAAOqD,SAAShB,EAAcjB,KAAM,UACtCiB,EAAcjB,KAAOpB,EAAOsD,QAAQjB,EAAcjB,KAAM,QACxDiB,EAAckB,UAAW,GAEvBlB,EAAcjB,KAAKoC,OAAS,EAC9B,MAAM,IAAIf,MAAM,sDAElBJ,EAAcjB,KAAOpB,EAAOyD,MAAMpB,EAAcjB,MAGtB,WAAvBiB,EAAcjB,MACS,UAAzBiB,EAAcqB,OACf5B,EAAYV,KAAO,QACc,WAAvBiB,EAAcjB,MACD,YAAvBiB,EAAcjB,MACbiB,EAAoB,KAGY,WAAvBA,EAAcjB,MACD,QAAvBiB,EAAcjB,MACbiB,EAAoB,KAEW,YAAvBA,EAAcjB,KACvBU,EAAYV,KAAO,WACa,WAAvBiB,EAAcjB,KACnBiB,EAAcnB,WAChBY,EAAYV,KAAO,WAEnBU,EAAYV,KAAO,WAEXtB,EAAM6D,YAAYtB,EAAoB,MAGhDP,EAAYV,KAAOiB,EAAcjB,KAFjCU,EAAYV,KAAO,SAVnBU,EAAYV,KAAO,QALpBU,EAAYV,KAAO,SACQ,WAAvBiB,EAAcjB,OAAmBiB,EAAcuB,KAAO,QAsC7D,IAfK9B,EAAY+B,SAAWxB,EAAoB,OAC1CP,EAAYgC,SACdhC,EAAY+B,QAAU7D,EAAOuC,IAAIF,EAAoB,KAAG,SAAUf,GAChE,OACEA,MAAOA,EACPsB,MAAOxC,EAAK2D,eAAejC,EAAYgC,SAAUxC,GAASQ,EAAYgC,SAASxC,GAASA,KAK5FQ,EAAY+B,QAAUxB,EAAoB,MAKpB,eAArBP,EAAYV,MAA0BiB,EAAchB,MAAO,CAC9D,IAAI2C,EAAY3B,EAAchB,MAAY,KACtC2C,IACF3B,EAAchB,MAAM4C,+BAAgC,IAEjDD,GAAa3B,EAAchB,MAAM,KACpC2C,EAAY3B,EAAchB,MAAM,GAAS,QAEvCgB,EAAchB,MAAM,GAAG4C,+BAAgC,GAQlC,WAAvB5B,EAAcjB,MAChBhB,EAAKyB,KAAKQ,EAAcnB,WAAY,CAACgD,EAAMC,KACzC7B,EAAKL,YAAYzB,KAAK0B,iBACpBF,IAAKF,EAAYE,IAAM,IAAMmC,OAUrC,GAJKrC,EAAYV,OACfU,EAAYV,KAAO,UAErBM,EAAOrB,EAAayB,EAAYV,OAE9B,MAAM,IAAIqB,MAAM,4DACdX,EAAYV,KAAO,KAIvB,GAAIiB,GAKF,IAAKX,EAAK0C,aAAe1C,EAAK2C,OACN,mBAArBvC,EAAYV,MACW,WAAvBiB,EAAcjB,KACf,MAAM,IAAIqB,MAAM,uFACyBX,EAAYE,IAAM,8CACZF,EAAYV,KAAO,WAOpE,GAAIM,EAAK0C,YAAoC,mBAArBtC,EAAYV,KAClC,MAAM,IAAIqB,MAAM,4CACRX,EAAYV,KAAO,sEAsD/B,OAhDAU,EAAYwC,MAAQlE,EAAK6C,eAAenB,EAAYkB,IAAM,IAG1DV,EAAKR,YAAcA,EACnBQ,EAAKD,cAAgBA,EACrBC,EAAKZ,KAAOA,EACZY,EAAKb,UAAYjB,KAGZsB,EAAYyC,WACfzC,EAAYyC,aAIVjC,EAAKZ,KAAK2C,OAcVrC,EADEF,EAAYT,MACRS,EAAYT,MAAM,IAAMS,EAAYT,MAGpCS,EAAYE,IAAM,KAEtBlC,EAAMqC,SAASH,KACjBA,GAAQA,IAAKA,IAEfM,EAAKkC,iBAAiBhE,KAAK0B,gBAAgBF,KAEpCF,EAAYT,OAEnBjB,EAAKyB,KAAKC,EAAYT,MAAQoD,IACxB3E,EAAMqC,SAASsC,KACjBA,GAASzC,IAAKyC,IAEhBnC,EAAKL,YAAYzB,KAAK0B,gBAAgBuC,MAInCnC,GAkBT/B,EAASK,UAAUgB,qBAAuB,WACxCpB,KAAKE,KAAKkB,qBAAqBpB,KAAKG,SAASW,QAW/Cf,EAASK,UAAU8D,OAAS,SAAUC,GAC/BA,IACLnE,KAAKmE,QAAUA,EACfnE,KAAKE,KAAKgE,SAKNlE,KAAKoE,oBACP1E,EAAEyE,GAASE,SAAS,0BAUxBtE,EAASK,UAAUkE,eAAiB,SAAUC,GAE5C,IAAIC,EAAI,SAAStE,GACf,IAAK,IAAIuE,EAAE,EAAEA,EAAEvE,EAAKwE,SAAS1B,OAAOyB,IAClCF,EAASrE,EAAKwE,SAASD,IACvBD,EAAEtE,EAAKwE,SAASD,KAGpBD,EAAExE,KAAKE,OAITH,EAASK,UAAUuE,SAAW,SAASC,GAErC,IAAIC,EAASlF,EAASmF,aAAa9E,KAAKmE,SACpCY,GAAS,EAET1B,EAAUrD,KAAKG,SAEnB,IAAuB,IAAnBkD,EAAQsB,SAAkB,CAC5B,IAAIK,GAAY,EAQhB,GAP6B,iBAAlB3B,EAAQsB,SACbtF,EAAQ4F,oBACVD,EAAY3F,EAAQ4F,kBAAkBC,kBAAkB,yBAG1DF,EAAY3B,EAAQsB,SAElBK,EAAW,CACb,IAAIG,EAAIH,EAAUL,SAASE,EAAQ7E,KAAKG,SAASM,QACjDf,EAAEM,KAAKmE,SAASiB,gBAAe,EAAM/B,GACjC8B,EAAEJ,OAAO/B,SACN+B,IAAQA,MACbA,EAASA,EAAOM,OAAOF,EAAEJ,UAa/B,OARIA,IAAWH,IACTvB,EAAQiC,cACVjC,EAAQiC,cAAcP,EAAO/E,KAAKmE,SAElCzE,EAAEM,KAAKmE,SAASiB,eAAeL,EAAO1B,KAIlC0B,OAASA,IAInBhF,EAASK,UAAUmF,OAAS,SAASC,GAEnC,IAAIC,EAAY,WAKd,OAJID,IACFA,EAAIE,iBACJF,EAAIG,oBAEC,GAELd,EAASlF,EAASmF,aAAa9E,KAAKmE,SACpCd,EAAUrD,KAAKG,SAEfyF,GAAI,EAQR,GAPA5F,KAAKsE,eAAe,SAASuB,GACvBD,GACAC,EAAI3E,KAAK4E,WACXF,GAAOC,EAAI3E,KAAK4E,SAASN,EAAKK,MAI9BD,EAAK,OAAOH,IAEhB,IAAIM,EAAY/F,KAAK2E,WAErB,OAAItB,EAAQyC,WAAazC,EAAQyC,SAASC,EAAUhB,OAAOF,GAClDY,IAGLM,EAAUhB,OAAeU,OAEzBpC,EAAQ2C,eAAkB3C,EAAQ2C,cAAcnB,KAC3CY,KAsBX1F,EAASK,UAAUgE,iBAAmB,WACpC,IAAI6B,EAAe,SAAU1E,GAC3B,IAAKA,EAAS,OAAO,KACrB,GAAIA,EAAQwB,UAA8B,YAAjBxB,EAAQX,KAC/B,OAAOW,EAGT,IAAImC,EAAOlE,EAAO0G,KAAK3E,EAAQb,WAAY,SAAUyF,GACnD,OAAOF,EAAaE,KAEtB,OAAIzC,IAIAnC,EAAQV,QAER6C,EADEpE,EAAMyB,QAAQQ,EAAQV,OACjBrB,EAAO0G,KAAK3E,EAAQV,MAAO,SAAUoD,GAC1C,OAAOgC,EAAahC,KAIfgC,EAAa1E,EAAQV,QAGrB6C,OAVX,IAeF,OAAOuC,EAAajG,KAAKG,SAASM,SAI7Bd,EAASI,SAAWA","file":"../form-tree.js","sourcesContent":["define([\r\n  \"skylark-langx-globals\",\r\n  \"skylark-langx-types\",\r\n  \"skylark-langx-objects\",\r\n  \"skylark-langx-arrays\",\r\n  \"skylark-langx-strings\",\r\n  \"skylark-jquery\",\r\n  \"./jsonform\",\r\n  \"./util\",\r\n  \"./element-types\",\r\n  \"./form-node\"\r\n],function(globals,types,objects,arrays,strings,$,jsonform,util,elementTypes,formNode){\r\n  //3098-3649\r\n\r\n  /**\r\n   * Form tree class.\r\n   *\r\n   * Holds the internal representation of the form.\r\n   * The tree is always in sync with the rendered form, this allows to parse\r\n   * it easily.\r\n   *\r\n   * @class\r\n   */\r\n  var formTree = function () {\r\n    this.eventhandlers = [];\r\n    this.root = null;\r\n    this.formDesc = null;\r\n  };\r\n\r\n  /**\r\n   * Initializes the form tree structure from the JSONForm object\r\n   *\r\n   * This function is the main entry point of the JSONForm library.\r\n   *\r\n   * Initialization steps:\r\n   * 1. the internal tree structure that matches the JSONForm object\r\n   *  gets created (call to buildTree)\r\n   * 2. initial values are computed from previously submitted values\r\n   *  or from the default values defined in the JSON schema.\r\n   *\r\n   * When the function returns, the tree is ready to be rendered through\r\n   * a call to \"render\".\r\n   *\r\n   * @function\r\n   */\r\n  formTree.prototype.initialize = function (formDesc) {\r\n    formDesc = formDesc || {};\r\n\r\n    // Keep a pointer to the initial JSONForm\r\n    // (note clone returns a shallow copy, only first-level is cloned)\r\n    this.formDesc = objects.clone(formDesc);\r\n\r\n    this.formDesc.prefix = this.formDesc.prefix ||\r\n      'jsonform-' + strings.uniqueId();\r\n\r\n    // JSON schema shorthand\r\n    if (this.formDesc.schema && !this.formDesc.schema.properties) {\r\n      this.formDesc.schema = {\r\n        properties: this.formDesc.schema\r\n      };\r\n    }\r\n\r\n    // Ensure layout is set\r\n    this.formDesc.form = this.formDesc.form || [\r\n      '*',\r\n      {\r\n        type: 'actions',\r\n        items: [\r\n          {\r\n            type: 'submit',\r\n            value: 'Submit'\r\n          }\r\n        ]\r\n      }\r\n    ];\r\n    this.formDesc.form = (types.isArray(this.formDesc.form) ?\r\n      this.formDesc.form :\r\n      [this.formDesc.form]);\r\n\r\n    this.formDesc.params = this.formDesc.params || {};\r\n\r\n    // Create the root of the tree\r\n    this.root = new formNode();\r\n    this.root.ownerTree = this;\r\n    this.root.view = elementTypes['root'];\r\n\r\n    // Generate the tree from the form description\r\n    this.buildTree();\r\n\r\n    // Compute the values associated with each node\r\n    // (for arrays, the computation actually creates the form nodes)\r\n    this.computeInitialValues();\r\n  };\r\n\r\n\r\n  /**\r\n   * Constructs the tree from the form description.\r\n   *\r\n   * The function must be called once when the tree is first created.\r\n   *\r\n   * @function\r\n   */\r\n  formTree.prototype.buildTree = function () {\r\n    // Parse and generate the form structure based on the elements encountered:\r\n    // - '*' means \"generate all possible fields using default layout\"\r\n    // - a key reference to target a specific data element\r\n    // - a more complex object to generate specific form sections\r\n    util.each(this.formDesc.form,  (formElement) => {\r\n      if (formElement === '*') {\r\n        util.each(this.formDesc.schema.properties,  (element, key) => {\r\n          this.root.appendChild(this.buildFromLayout({\r\n            key: key\r\n          }));\r\n        });\r\n      }\r\n      else {\r\n        if (types.isString(formElement)) {\r\n          formElement = {\r\n            key: formElement\r\n          };\r\n        }\r\n        this.root.appendChild(this.buildFromLayout(formElement));\r\n      }\r\n    }, this);\r\n  };\r\n\r\n\r\n  /**\r\n   * Builds the internal form tree representation from the requested layout.\r\n   *\r\n   * The function is recursive, generating the node children as necessary.\r\n   * The function extracts the values from the previously submitted values\r\n   * (this.formDesc.value) or from default values defined in the schema.\r\n   *\r\n   * @function\r\n   * @param {Object} formElement JSONForm element to render\r\n   * @param {Object} context The parsing context (the array depth in particular)\r\n   * @return {Object} The node that matches the element.\r\n   */\r\n  formTree.prototype.buildFromLayout = function (formElement, context) {\r\n    var schemaElement = null;\r\n    var node = new formNode();\r\n    var view = null;\r\n    var key = null;\r\n\r\n    // The form element parameter directly comes from the initial\r\n    // JSONForm object. We'll make a shallow copy of it and of its children\r\n    // not to pollute the original object.\r\n    // (note JSON.parse(JSON.stringify()) cannot be used since there may be\r\n    // event handlers in there!)\r\n    formElement = objects.clone(formElement);\r\n    if (formElement.items) {\r\n      if (types.isArray(formElement.items)) {\r\n        formElement.items = arrays.map(formElement.items,objects.clone); \r\n      }\r\n      else {\r\n        formElement.items = [ objects.clone(formElement.items) ];\r\n      }\r\n    }\r\n\r\n    if (formElement.key) {\r\n      // The form element is directly linked to an element in the JSON\r\n      // schema. The properties of the form element override those of the\r\n      // element in the JSON schema. Properties from the JSON schema complete\r\n      // those of the form element otherwise.\r\n\r\n      // Retrieve the element from the JSON schema\r\n      schemaElement = util.getSchemaKey(\r\n        this.formDesc.schema.properties,\r\n        formElement.key);\r\n      if (!schemaElement) {\r\n        // The JSON Form is invalid!\r\n        throw new Error('The JSONForm object references the schema key \"' +\r\n          formElement.key + '\" but that key does not exist in the JSON schema');\r\n      }\r\n\r\n      // Schema element has just been found, let's trigger the\r\n      // \"onElementSchema\" event\r\n      // (tidoust: not sure what the use case for this is, keeping the\r\n      // code for backward compatibility)\r\n      if (this.formDesc.onElementSchema) {\r\n        this.formDesc.onElementSchema(formElement, schemaElement);\r\n      }\r\n\r\n      formElement.name =\r\n        formElement.name ||\r\n        formElement.key;\r\n      formElement.title =\r\n        formElement.title ||\r\n        schemaElement.title;\r\n      formElement.description =\r\n        formElement.description ||\r\n        schemaElement.description;\r\n      formElement.readOnly =\r\n        formElement.readOnly ||\r\n        schemaElement.readOnly ||\r\n        formElement.readonly ||\r\n        schemaElement.readonly;\r\n\r\n      // Compute the ID of the input field\r\n      if (!formElement.id) {\r\n        formElement.id = util.escapeSelector(this.formDesc.prefix) +\r\n          '-elt-' + util.slugify(formElement.key);\r\n      }\r\n\r\n      // Should empty strings be included in the final value?\r\n      // TODO: it's rather unclean to pass it through the schema.\r\n      if (formElement.allowEmpty) {\r\n        schemaElement._jsonform_allowEmpty = true;\r\n      }\r\n\r\n      // If the form element does not define its type, use the type of\r\n      // the schema element.\r\n      if (!formElement.type) {\r\n        // If schema type is an array containing only a type and \"null\",\r\n        // remove null and make the element non-required\r\n        if (types.isArray(schemaElement.type)) {\r\n          if (arrays.contains(schemaElement.type, \"null\")) {\r\n            schemaElement.type = arrays.without(schemaElement.type, \"null\");\r\n            schemaElement.required = false;\r\n          }\r\n          if (schemaElement.type.length > 1) {\r\n            throw new Error(\"Cannot process schema element with multiple types.\");\r\n          }\r\n          schemaElement.type = arrays.first(schemaElement.type);\r\n        }\r\n\r\n        if ((schemaElement.type === 'string') &&\r\n          (schemaElement.format === 'color')) {\r\n          formElement.type = 'color';\r\n        } else if ((schemaElement.type === 'number' ||\r\n          schemaElement.type === 'integer') &&\r\n          !schemaElement['enum']) {\r\n         formElement.type = 'number';\r\n         if (schemaElement.type === 'number') schemaElement.step = 'any';\r\n        } else if ((schemaElement.type === 'string' ||\r\n          schemaElement.type === 'any') &&\r\n          !schemaElement['enum']) {\r\n          formElement.type = 'text';\r\n        } else if (schemaElement.type === 'boolean') {\r\n          formElement.type = 'checkbox';\r\n        } else if (schemaElement.type === 'object') {\r\n          if (schemaElement.properties) {\r\n            formElement.type = 'fieldset';\r\n          } else {\r\n            formElement.type = 'textarea';\r\n          }\r\n        } else if (!types.isUndefined(schemaElement['enum'])) {\r\n          formElement.type = 'select';\r\n        } else {\r\n          formElement.type = schemaElement.type;\r\n        }\r\n      }\r\n\r\n      // Unless overridden in the definition of the form element (or unless\r\n      // there's a titleMap defined), use the enumeration list defined in\r\n      // the schema\r\n      if (!formElement.options && schemaElement['enum']) {\r\n        if (formElement.titleMap) {\r\n          formElement.options = arrays.map(schemaElement['enum'], function (value) {\r\n            return {\r\n              value: value,\r\n              title: util.hasOwnProperty(formElement.titleMap, value) ? formElement.titleMap[value] : value\r\n            };\r\n          });\r\n        }\r\n        else {\r\n          formElement.options = schemaElement['enum'];\r\n        }\r\n      }\r\n\r\n      // Flag a list of checkboxes with multiple choices\r\n      if ((formElement.type === 'checkboxes') && schemaElement.items) {\r\n        var itemsEnum = schemaElement.items['enum'];\r\n        if (itemsEnum) {\r\n          schemaElement.items._jsonform_checkboxes_as_array = true;\r\n        }\r\n        if (!itemsEnum && schemaElement.items[0]) {\r\n          itemsEnum = schemaElement.items[0]['enum'];\r\n          if (itemsEnum) {\r\n            schemaElement.items[0]._jsonform_checkboxes_as_array = true;\r\n          }\r\n        }\r\n      }\r\n\r\n      // If the form element targets an \"object\" in the JSON schema,\r\n      // we need to recurse through the list of children to create an\r\n      // input field per child property of the object in the JSON schema\r\n      if (schemaElement.type === 'object') {\r\n        util.each(schemaElement.properties, (prop, propName) => {\r\n          node.appendChild(this.buildFromLayout({\r\n            key: formElement.key + '.' + propName\r\n          }));\r\n        });\r\n      }\r\n    }\r\n\r\n    if (!formElement.type) {\r\n      formElement.type = 'none';\r\n    }\r\n    view = elementTypes[formElement.type];\r\n    if (!view) {\r\n      throw new Error('The JSONForm contains an element whose type is unknown: \"' +\r\n        formElement.type + '\"');\r\n    }\r\n\r\n\r\n    if (schemaElement) {\r\n      // The form element is linked to an element in the schema.\r\n      // Let's make sure the types are compatible.\r\n      // In particular, the element must not be a \"container\"\r\n      // (or must be an \"object\" or \"array\" container)\r\n      if (!view.inputfield && !view.array &&\r\n        (formElement.type !== 'selectfieldset') &&\r\n        (schemaElement.type !== 'object')) {\r\n        throw new Error('The JSONForm contains an element that links to an ' +\r\n          'element in the JSON schema (key: \"' + formElement.key + '\") ' +\r\n          'and that should not based on its type (\"' + formElement.type + '\")');\r\n      }\r\n    }\r\n    else {\r\n      // The form element is not linked to an element in the schema.\r\n      // This means the form element must be a \"container\" element,\r\n      // and must not define an input field.\r\n      if (view.inputfield && (formElement.type !== 'selectfieldset')) {\r\n        throw new Error('The JSONForm defines an element of type ' +\r\n          '\"' + formElement.type + '\" ' +\r\n          'but no \"key\" property to link the input field to the JSON schema');\r\n      }\r\n    }\r\n\r\n    // A few characters need to be escaped to use the ID as jQuery selector\r\n    formElement.iddot = util.escapeSelector(formElement.id || '');\r\n\r\n    // Initialize the form node from the form element and schema element\r\n    node.formElement = formElement;\r\n    node.schemaElement = schemaElement;\r\n    node.view = view;\r\n    node.ownerTree = this;\r\n\r\n    // Set event handlers\r\n    if (!formElement.handlers) {\r\n      formElement.handlers = {};\r\n    }\r\n\r\n    // Parse children recursively\r\n    if (node.view.array) {\r\n      // The form element is an array. The number of items in an array\r\n      // is by definition dynamic, up to the form user (through \"Add more\",\r\n      // \"Delete\" commands). The positions of the items in the array may\r\n      // also change over time (through \"Move up\", \"Move down\" commands).\r\n      //\r\n      // The form node stores a \"template\" node that serves as basis for\r\n      // the creation of an item in the array.\r\n      //\r\n      // Array items may be complex forms themselves, allowing for nesting.\r\n      //\r\n      // The initial values set the initial number of items in the array.\r\n      // Note a form element contains at least one item when it is rendered.\r\n      if (formElement.items) {\r\n        key = formElement.items[0] || formElement.items;\r\n      }\r\n      else {\r\n        key = formElement.key + '[]';\r\n      }\r\n      if (types.isString(key)) {\r\n        key = { key: key };\r\n      }\r\n      node.setChildTemplate(this.buildFromLayout(key));\r\n    }\r\n    else if (formElement.items) {\r\n      // The form element defines children elements\r\n      util.each(formElement.items, (item)=>{\r\n        if (types.isString(item)) {\r\n          item = { key: item };\r\n        }\r\n        node.appendChild(this.buildFromLayout(item));\r\n      });\r\n    }\r\n\r\n    return node;\r\n  };\r\n\r\n\r\n  /**\r\n   * Computes the values associated with each input field in the tree based\r\n   * on previously submitted values or default values in the JSON schema.\r\n   *\r\n   * For arrays, the function actually creates and inserts additional\r\n   * nodes in the tree based on previously submitted values (also ensuring\r\n   * that the array has at least one item).\r\n   *\r\n   * The function sets the array path on all nodes.\r\n   * It should be called once in the lifetime of a form tree right after\r\n   * the tree structure has been created.\r\n   *\r\n   * @function\r\n   */\r\n  formTree.prototype.computeInitialValues = function () {\r\n    this.root.computeInitialValues(this.formDesc.value);\r\n  };\r\n\r\n\r\n  /**\r\n   * Renders the form tree\r\n   *\r\n   * @function\r\n   * @param {Node} domRoot The \"form\" element in the DOM tree that serves as\r\n   *  root for the form\r\n   */\r\n  formTree.prototype.render = function (domRoot) {\r\n    if (!domRoot) return;\r\n    this.domRoot = domRoot;\r\n    this.root.render();\r\n\r\n    // If the schema defines required fields, flag the form with the\r\n    // \"jsonform-hasrequired\" class for styling purpose\r\n    // (typically so that users may display a legend)\r\n    if (this.hasRequiredField()) {\r\n      $(domRoot).addClass('jsonform-hasrequired');\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Walks down the element tree with a callback\r\n   *\r\n   * @function\r\n   * @param {Function} callback The callback to call on each element\r\n   */\r\n  formTree.prototype.forEachElement = function (callback) {\r\n\r\n    var f = function(root) {\r\n      for (var i=0;i<root.children.length;i++) {\r\n        callback(root.children[i]);\r\n        f(root.children[i]);\r\n      }\r\n    };\r\n    f(this.root);\r\n\r\n  };\r\n\r\n  formTree.prototype.validate = function(noErrorDisplay) {\r\n\r\n    var values = jsonform.getFormValue(this.domRoot);\r\n    var errors = false;\r\n\r\n    var options = this.formDesc;\r\n\r\n    if (options.validate!==false) {\r\n      var validator = false;\r\n      if (typeof options.validate!=\"object\") {\r\n        if (globals.JSONFormValidator) {\r\n          validator = globals.JSONFormValidator.createEnvironment(\"json-schema-draft-03\");\r\n        }\r\n      } else {\r\n        validator = options.validate;\r\n      }\r\n      if (validator) {\r\n        var v = validator.validate(values, this.formDesc.schema);\r\n        $(this.domRoot).jsonFormErrors(false,options);\r\n        if (v.errors.length) {\r\n          if (!errors) errors = [];\r\n          errors = errors.concat(v.errors);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (errors && !noErrorDisplay) {\r\n      if (options.displayErrors) {\r\n        options.displayErrors(errors,this.domRoot);\r\n      } else {\r\n        $(this.domRoot).jsonFormErrors(errors,options);\r\n      }\r\n    }\r\n\r\n    return {\"errors\":errors}\r\n\r\n  }\r\n\r\n  formTree.prototype.submit = function(evt) {\r\n\r\n    var stopEvent = function() {\r\n      if (evt) {\r\n        evt.preventDefault();\r\n        evt.stopPropagation();\r\n      }\r\n      return false;\r\n    };\r\n    var values = jsonform.getFormValue(this.domRoot);\r\n    var options = this.formDesc;\r\n\r\n    var brk=false;\r\n    this.forEachElement(function(elt) {\r\n      if (brk) return;\r\n      if (elt.view.onSubmit) {\r\n        brk = !elt.view.onSubmit(evt, elt); //may be called multiple times!!\r\n      }\r\n    });\r\n\r\n    if (brk) return stopEvent();\r\n\r\n    var validated = this.validate();\r\n\r\n    if (options.onSubmit && !options.onSubmit(validated.errors,values)) {\r\n      return stopEvent();\r\n    }\r\n\r\n    if (validated.errors) return stopEvent();\r\n\r\n    if (options.onSubmitValid && !options.onSubmitValid(values)) {\r\n      return stopEvent();\r\n    }\r\n\r\n    return false;\r\n\r\n  };\r\n\r\n\r\n  /**\r\n   * Returns true if the form displays a \"required\" field.\r\n   *\r\n   * To keep things simple, the function parses the form's schema and returns\r\n   * true as soon as it finds a \"required\" flag even though, in theory, that\r\n   * schema key may not appear in the final form.\r\n   *\r\n   * Note that a \"required\" constraint on a boolean type is always enforced,\r\n   * the code skips such definitions.\r\n   *\r\n   * @function\r\n   * @return {boolean} True when the form has some required field,\r\n   *  false otherwise.\r\n   */\r\n  formTree.prototype.hasRequiredField = function () {\r\n    var parseElement = function (element) {\r\n      if (!element) return null;\r\n      if (element.required && (element.type !== 'boolean')) {\r\n        return element;\r\n      }\r\n\r\n      var prop = arrays.find(element.properties, function (property) {\r\n        return parseElement(property);\r\n      });\r\n      if (prop) {\r\n        return prop;\r\n      }\r\n\r\n      if (element.items) {\r\n        if (types.isArray(element.items)) {\r\n          prop = arrays.find(element.items, function (item) {\r\n            return parseElement(item);\r\n          });\r\n        }\r\n        else {\r\n          prop = parseElement(element.items);\r\n        }\r\n        if (prop) {\r\n          return prop;\r\n        }\r\n      }\r\n    };\r\n\r\n    return parseElement(this.formDesc.schema);\r\n  };\r\n\r\n\r\n  return jsonform.formTree = formTree;\r\n\r\n});\r\n"]}