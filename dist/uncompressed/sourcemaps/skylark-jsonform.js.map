{"version":3,"sources":["skylark-jsonform.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-jsonform.js","sourcesContent":["define('skylark-jsonform/jsonform',[\r\n  \"skylark-langx-ns\",\r\n  \"skylark-jquery\"\r\n],function(skylark,$) {\r\n\r\n\r\n    /**\r\n     * The jsonform object whose methods will be exposed to the window object\r\n     */\r\n    var jsonform = {util:{}};\r\n\r\n\r\n\r\n\r\n  return skylark.attach(\"intg.jsonform\",jsonform);\r\n\r\n});\ndefine('skylark-jsonform/util',[\r\n  \"skylark-langx\",\r\n  \"./jsonform\"\r\n],function(langx,jsonform){\r\n\r\n  //1519-1653\r\n  //1656-1684\r\n  //1725-1775\r\n\r\n    /**\r\n   * Regular expressions used to extract array indexes in input field names\r\n   */\r\n  var reArray = /\\[([0-9]*)\\](?=\\[|\\.|$)/g;\r\n\r\n    /**\r\n     * Template settings for form views\r\n     */\r\n    var fieldTemplateSettings = {\r\n      evaluate    : /<%([\\s\\S]+?)%>/g,\r\n      interpolate : /<%=([\\s\\S]+?)%>/g\r\n    };\r\n\r\n    /**\r\n     * Template settings for value replacement\r\n     */\r\n    var valueTemplateSettings = {\r\n      evaluate    : /\\{\\[([\\s\\S]+?)\\]\\}/g,\r\n      interpolate : /\\{\\{([\\s\\S]+?)\\}\\}/g\r\n    };\r\n\r\n\r\n    /**\r\n     * Returns true if given property is directly property of an object\r\n     */\r\n    var hasOwnProperty = function (obj, prop) {\r\n      return typeof obj === 'object' && obj.hasOwnProperty(prop);\r\n    }\r\n\r\n  /**\r\n   * Escapes selector name for use with jQuery\r\n   *\r\n   * All meta-characters listed in jQuery doc are escaped:\r\n   * http://api.jquery.com/category/selectors/\r\n   *\r\n   * @function\r\n   * @param {String} selector The jQuery selector to escape\r\n   * @return {String} The escaped selector.\r\n   */\r\n  var escapeSelector = function (selector) {\r\n    return selector.replace(/([ \\!\\\"\\#\\$\\%\\&\\'\\(\\)\\*\\+\\,\\.\\/\\:\\;<\\=\\>\\?\\@\\[\\\\\\]\\^\\`\\{\\|\\}\\~])/g, '\\\\$1');\r\n  };\r\n\r\n  /**\r\n   *\r\n   * Slugifies a string by replacing spaces with _. Used to create\r\n   * valid classnames and ids for the form.\r\n   *\r\n   * @function\r\n   * @param {String} str The string to slugify\r\n   * @return {String} The slugified string.\r\n   */\r\n  var slugify = function(str) {\r\n    return str.replace(/\\ /g, '_');\r\n  }\r\n\r\n\r\n  /**\r\n   * Returns true if given value is neither \"undefined\" nor null\r\n   */\r\n  var isSet = function (value) {\r\n    return !(langx.isUndefined(value) || langx.isNull(value));\r\n  };\r\n\r\n\r\n\r\n  //Allow to access subproperties by splitting \".\"\r\n  /**\r\n   * Retrieves the key identified by a path selector in the structured object.\r\n   *\r\n   * Levels in the path are separated by a dot. Array items are marked\r\n   * with [x]. For instance:\r\n   *  foo.bar[3].baz\r\n   *\r\n   * @function\r\n   * @param {Object} obj Structured object to parse\r\n   * @param {String} key Path to the key to retrieve\r\n   * @param {boolean} ignoreArrays True to use first element in an array when\r\n   *   stucked on a property. This parameter is basically only useful when\r\n   *   parsing a JSON schema for which the \"items\" property may either be an\r\n   *   object or an array with one object (only one because JSON form does not\r\n   *   support mix of items for arrays).\r\n   * @return {Object} The key's value.\r\n   */\r\n  var getObjKey = function (obj, key, ignoreArrays) {\r\n    var innerobj = obj;\r\n    var keyparts = key.split(\".\");\r\n    var subkey = null;\r\n    var arrayMatch = null;\r\n    var prop = null;\r\n\r\n    for (var i = 0; i < keyparts.length; i++) {\r\n      if ((innerobj === null) || (typeof innerobj !== \"object\")) return null;\r\n      subkey = keyparts[i];\r\n      prop = subkey.replace(reArray, '');\r\n      reArray.lastIndex = 0;\r\n      arrayMatch = reArray.exec(subkey);\r\n      if (arrayMatch) {\r\n        while (true) {\r\n          if (prop && !langx.isArray(innerobj[prop])) return null;\r\n          innerobj = prop ? innerobj[prop][parseInt(arrayMatch[1])] : innerobj[parseInt(arrayMatch[1])];\r\n          arrayMatch = reArray.exec(subkey);\r\n          if (!arrayMatch) break;\r\n          // In the case of multidimensional arrays,\r\n          // we should not take innerobj[prop][0] anymore,\r\n          // but innerobj[0] directly\r\n          prop = null;\r\n        }\r\n      } else if (ignoreArrays &&\r\n          !innerobj[prop] &&\r\n          langx.isArray(innerobj) &&\r\n          innerobj[0]) {\r\n        innerobj = innerobj[0][prop];\r\n      } else {\r\n        innerobj = innerobj[prop];\r\n      }\r\n    }\r\n\r\n    if (ignoreArrays && langx.isArray(innerobj) && innerobj[0]) {\r\n      return innerobj[0];\r\n    } else {\r\n      return innerobj;\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Sets the key identified by a path selector to the given value.\r\n   *\r\n   * Levels in the path are separated by a dot. Array items are marked\r\n   * with [x]. For instance:\r\n   *  foo.bar[3].baz\r\n   *\r\n   * The hierarchy is automatically created if it does not exist yet.\r\n   *\r\n   * @function\r\n   * @param {Object} obj The object to build\r\n   * @param {String} key The path to the key to set where each level\r\n   *  is separated by a dot, and array items are flagged with [x].\r\n   * @param {Object} value The value to set, may be of any type.\r\n   */\r\n  var setObjKey = function(obj,key,value) {\r\n    var innerobj = obj;\r\n    var keyparts = key.split(\".\");\r\n    var subkey = null;\r\n    var arrayMatch = null;\r\n    var prop = null;\r\n\r\n    for (var i = 0; i < keyparts.length-1; i++) {\r\n      subkey = keyparts[i];\r\n      prop = subkey.replace(reArray, '');\r\n      reArray.lastIndex = 0;\r\n      arrayMatch = reArray.exec(subkey);\r\n      if (arrayMatch) {\r\n        // Subkey is part of an array\r\n        while (true) {\r\n          if (!langx.isArray(innerobj[prop])) {\r\n            innerobj[prop] = [];\r\n          }\r\n          innerobj = innerobj[prop];\r\n          prop = parseInt(arrayMatch[1], 10);\r\n          arrayMatch = reArray.exec(subkey);\r\n          if (!arrayMatch) break;\r\n        }\r\n        if ((typeof innerobj[prop] !== 'object') ||\r\n          (innerobj[prop] === null)) {\r\n          innerobj[prop] = {};\r\n        }\r\n        innerobj = innerobj[prop];\r\n      }\r\n      else {\r\n        // \"Normal\" subkey\r\n        if ((typeof innerobj[prop] !== 'object') ||\r\n          (innerobj[prop] === null)) {\r\n          innerobj[prop] = {};\r\n        }\r\n        innerobj = innerobj[prop];\r\n      }\r\n    }\r\n\r\n    // Set the final value\r\n    subkey = keyparts[keyparts.length - 1];\r\n    prop = subkey.replace(reArray, '');\r\n    reArray.lastIndex = 0;\r\n    arrayMatch = reArray.exec(subkey);\r\n    if (arrayMatch) {\r\n      while (true) {\r\n        if (!langx.isArray(innerobj[prop])) {\r\n          innerobj[prop] = [];\r\n        }\r\n        innerobj = innerobj[prop];\r\n        prop = parseInt(arrayMatch[1], 10);\r\n        arrayMatch = reArray.exec(subkey);\r\n        if (!arrayMatch) break;\r\n      }\r\n      innerobj[prop] = value;\r\n    }\r\n    else {\r\n      innerobj[prop] = value;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Retrieves the key definition from the given schema.\r\n   *\r\n   * The key is identified by the path that leads to the key in the\r\n   * structured object that the schema would generate. Each level is\r\n   * separated by a '.'. Array levels are marked with []. For instance:\r\n   *  foo.bar[].baz\r\n   * ... to retrieve the definition of the key at the following location\r\n   * in the JSON schema (using a dotted path notation):\r\n   *  foo.properties.bar.items.properties.baz\r\n   *\r\n   * @function\r\n   * @param {Object} schema The JSON schema to retrieve the key from\r\n   * @param {String} key The path to the key, each level being separated\r\n   *  by a dot and array items being flagged with [].\r\n   * @return {Object} The key definition in the schema, null if not found.\r\n   */\r\n  var getSchemaKey = function(schema,key) {\r\n    var schemaKey = key\r\n      .replace(/\\./g, '.properties.')\r\n      .replace(/\\[[0-9]*\\]/g, '.items');\r\n    var schemaDef = jsonform.util.getObjKey(schema, schemaKey, true);\r\n    if (schemaDef && schemaDef.$ref) {\r\n      throw new Error('JSONForm does not yet support schemas that use the ' +\r\n        '$ref keyword. See: https://github.com/joshfire/jsonform/issues/54');\r\n    }\r\n    return schemaDef;\r\n  };\r\n\r\n\r\n  /**\r\n   * Applies the array path to the key path.\r\n   *\r\n   * For instance, if the key path is:\r\n   *  foo.bar[].baz.toto[].truc[].bidule\r\n   * and the arrayPath [4, 2], the returned key will be:\r\n   *  foo.bar[4].baz.toto[2].truc[].bidule\r\n   *\r\n   * @function\r\n   * @param {String} key The path to the key in the schema, each level being\r\n   *  separated by a dot and array items being flagged with [].\r\n   * @param {Array(Number)} arrayPath The array path to apply, e.g. [4, 2]\r\n   * @return {String} The path to the key that matches the array path.\r\n   */\r\n  var applyArrayPath = function (key, arrayPath) {\r\n    var depth = 0;\r\n    if (!key) return null;\r\n    if (!arrayPath || (arrayPath.length === 0)) return key;\r\n    var newKey = key.replace(reArray, function (str, p1) {\r\n      // Note this function gets called as many times as there are [x] in the ID,\r\n      // from left to right in the string. The goal is to replace the [x] with\r\n      // the appropriate index in the new array path, if defined.\r\n      var newIndex = str;\r\n      if (isSet(arrayPath[depth])) {\r\n        newIndex = '[' + arrayPath[depth] + ']';\r\n      }\r\n      depth += 1;\r\n      return newIndex;\r\n    });\r\n    return newKey;\r\n  };\r\n\r\n  var max = function(arr) {\r\n    return arr.reduce(function(a, b) {\r\n      return Math.max(a, b);\r\n    });\r\n  };\r\n\r\n  function each(arrays,fn) {\r\n    return langx.each(arrays,fn,true);\r\n  }\r\n\r\n  return jsonform.util = {\r\n    fieldTemplateSettings,\r\n    valueTemplateSettings,\r\n    each,\r\n    hasOwnProperty,\r\n    escapeSelector,\r\n    slugify,\r\n    isSet,\r\n    applyArrayPath,\r\n    getObjKey,\r\n    setObjKey,\r\n    getSchemaKey,\r\n    max\r\n  };\r\n\r\n});\r\n\ndefine('skylark-jsonform/element-types',[\r\n  \"skylark-langx\",\r\n  \"skylark-jquery\",\r\n  \"./jsonform\",\r\n  \"./util\"\r\n],function(langx,$,jsonform,util){\r\n  //245-1516\r\n  var fileDisplayTemplate = '<div class=\"_jsonform-preview\">' +\r\n    '<% if (value.type==\"image\") { %>' +\r\n    '<img class=\"jsonform-preview\" id=\"jsonformpreview-<%= id %>\" src=\"<%= value.url %>\" />' +\r\n    '<% } else { %>' +\r\n    '<a href=\"<%= value.url %>\"><%= value.name %></a> (<%= Math.ceil(value.size/1024) %>kB)' +\r\n    '<% } %>' +\r\n    '</div>' +\r\n    '<a href=\"#\" class=\"btn btn-default _jsonform-delete\"><i class=\"glyphicon glyphicon-remove\" title=\"Remove\"></i></a> ';\r\n\r\n  var inputFieldTemplate = function (type) {\r\n    return {\r\n      'template': '<input type=\"' + type + '\" ' +\r\n        'class=\\'form-control<%= (fieldHtmlClass ? \" \" + fieldHtmlClass : \"\") %>\\'' +\r\n        'name=\"<%= node.name %>\" value=\"<%= escape(value) %>\" id=\"<%= id %>\"' +\r\n        ' aria-label=\"<%= node.title ? escape(node.title) : node.name %>\"' +\r\n        '<%= (node.disabled? \" disabled\" : \"\")%>' +\r\n        '<%= (node.readOnly ? \" readonly=\\'readonly\\'\" : \"\") %>' +\r\n        '<%= (node.schemaElement && (node.schemaElement.step > 0 || node.schemaElement.step == \"any\") ? \" step=\\'\" + node.schemaElement.step + \"\\'\" : \"\") %>' +\r\n        '<%= (node.schemaElement && node.schemaElement.minLength ? \" minlength=\\'\" + node.schemaElement.minLength + \"\\'\" : \"\") %>' +\r\n        '<%= (node.schemaElement && node.schemaElement.maxLength ? \" maxlength=\\'\" + node.schemaElement.maxLength + \"\\'\" : \"\") %>' +\r\n        '<%= (node.schemaElement && node.schemaElement.required && (node.schemaElement.type !== \"boolean\") ? \" required=\\'required\\'\" : \"\") %>' +\r\n        '<%= (node.placeholder? \" placeholder=\" + \\'\"\\' + escape(node.placeholder) + \\'\"\\' : \"\")%>' +\r\n        ' />',\r\n      'fieldtemplate': true,\r\n      'inputfield': true\r\n    }\r\n  };\r\n\r\n  jsonform.elementTypes = {\r\n    'none': {\r\n      'template': ''\r\n    },\r\n    'root': {\r\n      'template': '<div><%= children %></div>'\r\n    },\r\n    'text': inputFieldTemplate('text'),\r\n    'password': inputFieldTemplate('password'),\r\n    'date': inputFieldTemplate('date'),\r\n    'datetime': inputFieldTemplate('datetime'),\r\n    'datetime-local': inputFieldTemplate('datetime-local'),\r\n    'email': inputFieldTemplate('email'),\r\n    'month': inputFieldTemplate('month'),\r\n    'number': inputFieldTemplate('number'),\r\n    'search': inputFieldTemplate('search'),\r\n    'tel': inputFieldTemplate('tel'),\r\n    'time': inputFieldTemplate('time'),\r\n    'url': inputFieldTemplate('url'),\r\n    'week': inputFieldTemplate('week'),\r\n    'range': {\r\n      'template': '<div class=\"range\"><input type=\"range\" ' +\r\n        '<%= (fieldHtmlClass ? \"class=\\'\" + fieldHtmlClass + \"\\' \" : \"\") %>' +\r\n        'name=\"<%= node.name %>\" value=\"<%= escape(value) %>\" id=\"<%= id %>\"' +\r\n        ' aria-label=\"<%= node.title ? escape(node.title) : node.name %>\"' +\r\n        '<%= (node.disabled? \" disabled\" : \"\")%>' +\r\n        ' min=<%= range.min %>' +\r\n        ' max=<%= range.max %>' +\r\n        ' step=<%= range.step %>' +\r\n        '<%= (node.schemaElement && node.schemaElement.required ? \" required=\\'required\\'\" : \"\") %>' +\r\n        ' /><% if (range.indicator) { %><span class=\"range-value\" rel=\"<%= id %>\"><%= escape(value) %></span><% } %></div>',\r\n      'fieldtemplate': true,\r\n      'inputfield': true,\r\n      'onInput': function(evt, elt) {\r\n        const valueIndicator = document.querySelector('span.range-value[rel=\"' + elt.id + '\"]');\r\n        if (valueIndicator) {\r\n          valueIndicator.innerText = evt.target.value;\r\n        }\r\n      },\r\n      'onBeforeRender': function (data, node) {\r\n        data.range = {\r\n          min: 1,\r\n          max: 100,\r\n          step: 1,\r\n          indicator: false\r\n        };\r\n        if (!node || !node.schemaElement) return;\r\n        if (node.formElement && node.formElement.step) {\r\n          data.range.step = node.formElement.step;\r\n        }\r\n        if (node.formElement && node.formElement.indicator) {\r\n          data.range.indicator = node.formElement.indicator;\r\n        }\r\n        if (typeof node.schemaElement.minimum !== 'undefined') {\r\n          if (node.schemaElement.exclusiveMinimum) {\r\n            data.range.min = node.schemaElement.minimum + data.range.step;\r\n          }\r\n          else {\r\n            data.range.min = node.schemaElement.minimum;\r\n          }\r\n        }\r\n        if (typeof node.schemaElement.maximum !== 'undefined') {\r\n          if (node.schemaElement.exclusiveMaximum) {\r\n            data.range.max = node.schemaElement.maximum - data.range.step;\r\n          }\r\n          else {\r\n            data.range.max = node.schemaElement.maximum;\r\n          }\r\n        }\r\n      }\r\n    },\r\n    'color':{\r\n      'template':'<input type=\"text\" ' +\r\n        '<%= (fieldHtmlClass ? \"class=\\'\" + fieldHtmlClass + \"\\' \" : \"\") %>' +\r\n        'name=\"<%= node.name %>\" value=\"<%= escape(value) %>\" id=\"<%= id %>\"' +\r\n        ' aria-label=\"<%= node.title ? escape(node.title) : node.name %>\"' +\r\n        '<%= (node.disabled? \" disabled\" : \"\")%>' +\r\n        '<%= (node.schemaElement && node.schemaElement.required ? \" required=\\'required\\'\" : \"\") %>' +\r\n        ' />',\r\n      'fieldtemplate': true,\r\n      'inputfield': true,\r\n      'onInsert': function(evt, node) {\r\n        $(node.el).find('#' + util.escapeSelector(node.id)).spectrum({\r\n          preferredFormat: \"hex\",\r\n          showInput: true\r\n        });\r\n      }\r\n    },\r\n    'textarea':{\r\n      'template':'<textarea id=\"<%= id %>\" name=\"<%= node.name %>\" ' +\r\n        '<%= (fieldHtmlClass ? \"class=\\'\" + fieldHtmlClass + \"\\' \" : \"\") %>' +\r\n        'style=\"height:<%= elt.height || \"150px\" %>;width:<%= elt.width || \"100%\" %>;\"' +\r\n        ' aria-label=\"<%= node.title ? escape(node.title) : node.name %>\"' +\r\n        '<%= (node.disabled? \" disabled\" : \"\")%>' +\r\n        '<%= (node.readOnly ? \" readonly=\\'readonly\\'\" : \"\") %>' +\r\n        '<%= (node.schemaElement && node.schemaElement.minLength ? \" minlength=\\'\" + node.schemaElement.minLength + \"\\'\" : \"\") %>' +\r\n        '<%= (node.schemaElement && node.schemaElement.maxLength ? \" maxlength=\\'\" + node.schemaElement.maxLength + \"\\'\" : \"\") %>' +\r\n        '<%= (node.schemaElement && node.schemaElement.required ? \" required=\\'required\\'\" : \"\") %>' +\r\n        '<%= (node.placeholder? \" placeholder=\" + \\'\"\\' + escape(node.placeholder) + \\'\"\\' : \"\")%>' +\r\n        '><%= value %></textarea>',\r\n      'fieldtemplate': true,\r\n      'inputfield': true\r\n    },\r\n    'wysihtml5':{\r\n      'template':'<textarea id=\"<%= id %>\" name=\"<%= node.name %>\" style=\"height:<%= elt.height || \"300px\" %>;width:<%= elt.width || \"100%\" %>;\"' +\r\n        ' aria-label=\"<%= node.title ? escape(node.title) : node.name %>\"' +\r\n        '<%= (fieldHtmlClass ? \"class=\\'\" + fieldHtmlClass + \"\\' \" : \"\") %>' +\r\n        '<%= (node.disabled? \" disabled\" : \"\")%>' +\r\n        '<%= (node.readOnly ? \" readonly=\\'readonly\\'\" : \"\") %>' +\r\n        '<%= (node.schemaElement && node.schemaElement.minLength ? \" minlength=\\'\" + node.schemaElement.minLength + \"\\'\" : \"\") %>' +\r\n        '<%= (node.schemaElement && node.schemaElement.maxLength ? \" maxlength=\\'\" + node.schemaElement.maxLength + \"\\'\" : \"\") %>' +\r\n        '<%= (node.schemaElement && node.schemaElement.required ? \" required=\\'required\\'\" : \"\") %>' +\r\n        '<%= (node.placeholder? \" placeholder=\" + \\'\"\\' + escape(node.placeholder) + \\'\"\\' : \"\")%>' +\r\n        '><%= value %></textarea>',\r\n      'fieldtemplate': true,\r\n      'inputfield': true,\r\n      'onInsert': function (evt, node) {\r\n        var setup = function () {\r\n          //protect from double init\r\n          if ($(node.el).data(\"wysihtml5\")) return;\r\n          $(node.el).data(\"wysihtml5_loaded\",true);\r\n\r\n          $(node.el).find('#' + util.escapeSelector(node.id)).wysihtml5({\r\n            \"html\": true,\r\n            \"link\": true,\r\n            \"font-styles\":true,\r\n            \"image\": false,\r\n            \"events\": {\r\n              \"load\": function () {\r\n                // In chrome, if an element is required and hidden, it leads to\r\n                // the error 'An invalid form control with name='' is not focusable'\r\n                // See http://stackoverflow.com/questions/7168645/invalid-form-control-only-in-google-chrome\r\n                $(this.textareaElement).removeAttr('required');\r\n              }\r\n            }\r\n          });\r\n        };\r\n\r\n        // Is there a setup hook?\r\n        if (window.jsonform_wysihtml5_setup) {\r\n          window.jsonform_wysihtml5_setup(setup);\r\n          return;\r\n        }\r\n\r\n        // Wait until wysihtml5 is loaded\r\n        var itv = window.setInterval(function() {\r\n          if (window.wysihtml5) {\r\n            window.clearInterval(itv);\r\n            setup();\r\n          }\r\n        },1000);\r\n      }\r\n    },\r\n    'ace':{\r\n      'template':'<div id=\"<%= id %>\" style=\"position:relative;height:<%= elt.height || \"300px\" %>;\"><div id=\"<%= id %>__ace\" style=\"width:<%= elt.width || \"100%\" %>;height:<%= elt.height || \"300px\" %>;\"></div><input type=\"hidden\" name=\"<%= node.name %>\" id=\"<%= id %>__hidden\" value=\"<%= escape(value) %>\"/></div>',\r\n      'fieldtemplate': true,\r\n      'inputfield': true,\r\n      'onInsert': function (evt, node) {\r\n        var setup = function () {\r\n          var formElement = node.formElement || {};\r\n          var ace = window.ace;\r\n          var editor = ace.edit($(node.el).find('#' + util.escapeSelector(node.id) + '__ace').get(0));\r\n          var idSelector = '#' + util.escapeSelector(node.id) + '__hidden';\r\n          // Force editor to use \"\\n\" for new lines, not to bump into ACE \"\\r\" conversion issue\r\n          // (ACE is ok with \"\\r\" on pasting but fails to return \"\\r\" when value is extracted)\r\n          editor.getSession().setNewLineMode('unix');\r\n          editor.renderer.setShowPrintMargin(false);\r\n          editor.setTheme(\"ace/theme/\"+(formElement.aceTheme||\"twilight\"));\r\n\r\n          if (formElement.aceMode) {\r\n            editor.getSession().setMode(\"ace/mode/\"+formElement.aceMode);\r\n          }\r\n          editor.getSession().setTabSize(2);\r\n\r\n          // Set the contents of the initial manifest file\r\n          editor.getSession().setValue(node.value||\"\");\r\n\r\n          //TODO: this is clearly sub-optimal\r\n          // 'Lazily' bind to the onchange 'ace' event to give\r\n          // priority to user edits\r\n          var lazyChanged = langx.debounce(function () {\r\n            $(node.el).find(idSelector).val(editor.getSession().getValue());\r\n            $(node.el).find(idSelector).change();\r\n          }, 600);\r\n          editor.getSession().on('change', lazyChanged);\r\n\r\n          editor.on('blur', function() {\r\n            $(node.el).find(idSelector).change();\r\n            $(node.el).find(idSelector).trigger(\"blur\");\r\n          });\r\n          editor.on('focus', function() {\r\n            $(node.el).find(idSelector).trigger(\"focus\");\r\n          });\r\n        };\r\n\r\n        // Is there a setup hook?\r\n        if (window.jsonform_ace_setup) {\r\n          window.jsonform_ace_setup(setup);\r\n          return;\r\n        }\r\n\r\n        // Wait until ACE is loaded\r\n        var itv = window.setInterval(function() {\r\n          if (window.ace) {\r\n            window.clearInterval(itv);\r\n            setup();\r\n          }\r\n        },1000);\r\n      }\r\n    },\r\n    'checkbox':{\r\n      'template': '<div class=\"checkbox\"><label><input type=\"checkbox\" id=\"<%= id %>\" ' +\r\n        '<%= (fieldHtmlClass ? \" class=\\'\" + fieldHtmlClass + \"\\'\": \"\") %>' +\r\n        'name=\"<%= node.name %>\" value=\"1\" <% if (value) {%>checked<% } %>' +\r\n        '<%= (node.disabled? \" disabled\" : \"\")%>' +\r\n        '<%= (node.schemaElement && node.schemaElement.required && (node.schemaElement.type !== \"boolean\") ? \" required=\\'required\\'\" : \"\") %>' +\r\n        ' /><%= node.inlinetitle || \"\" %>' +\r\n        '</label></div>',\r\n      'fieldtemplate': true,\r\n      'inputfield': true,\r\n      'getElement': function (el) {\r\n        return $(el).parent().get(0);\r\n      }\r\n    },\r\n    'file':{\r\n      'template':'<input class=\"input-file\" id=\"<%= id %>\" name=\"<%= node.name %>\" type=\"file\" ' +\r\n        '<%= (node.schemaElement && node.schemaElement.required ? \" required=\\'required\\'\" : \"\") %>' +\r\n        '<%= (node.formElement && node.formElement.accept ? (\" accept=\\'\" + node.formElement.accept + \"\\'\") : \"\") %>' +\r\n        '/>',\r\n      'fieldtemplate': true,\r\n      'inputfield': true\r\n    },\r\n    'file-hosted-public':{\r\n      'template':'<span><% if (value && (value.type||value.url)) { %>'+fileDisplayTemplate+'<% } %><input class=\"input-file\" id=\"_transloadit_<%= id %>\" type=\"file\" name=\"<%= transloaditname %>\" /><input data-transloadit-name=\"_transloadit_<%= transloaditname %>\" type=\"hidden\" id=\"<%= id %>\" name=\"<%= node.name %>\" value=\\'<%= escape(JSON.stringify(node.value)) %>\\' /></span>',\r\n      'fieldtemplate': true,\r\n      'inputfield': true,\r\n      'getElement': function (el) {\r\n        return $(el).parent().get(0);\r\n      },\r\n      'onBeforeRender': function (data, node) {\r\n\r\n        if (!node.ownerTree._transloadit_generic_public_index) {\r\n          node.ownerTree._transloadit_generic_public_index=1;\r\n        } else {\r\n          node.ownerTree._transloadit_generic_public_index++;\r\n        }\r\n\r\n        data.transloaditname = \"_transloadit_jsonform_genericupload_public_\"+node.ownerTree._transloadit_generic_public_index;\r\n\r\n        if (!node.ownerTree._transloadit_generic_elts) node.ownerTree._transloadit_generic_elts = {};\r\n        node.ownerTree._transloadit_generic_elts[data.transloaditname] = node;\r\n      },\r\n      'onChange': function(evt,elt) {\r\n        // The \"transloadit\" function should be called only once to enable\r\n        // the service when the form is submitted. Has it already been done?\r\n        if (elt.ownerTree._transloadit_bound) {\r\n          return false;\r\n        }\r\n        elt.ownerTree._transloadit_bound = true;\r\n\r\n        // Call the \"transloadit\" function on the form element\r\n        var formElt = $(elt.ownerTree.domRoot);\r\n        formElt.transloadit({\r\n          autoSubmit: false,\r\n          wait: true,\r\n          onSuccess: function (assembly) {\r\n            // Image has been uploaded. Check the \"results\" property that\r\n            // contains the list of files that Transloadit produced. There\r\n            // should be one image per file input in the form at most.\r\n            var results = langx.values(assembly.results);\r\n            results = langx.flatten(results);\r\n            util.each(results, function (result) {\r\n              // Save the assembly result in the right hidden input field\r\n              var id = elt.ownerTree._transloadit_generic_elts[result.field].id;\r\n              var input = formElt.find('#' + util.escapeSelector(id));\r\n              var nonEmptyKeys = langx.filter(langx.keys(result.meta), function (key) {\r\n                return !!util.isSet(result.meta[key]);\r\n              });\r\n              result.meta = langx.pick(result.meta, nonEmptyKeys);\r\n              input.val(JSON.stringify(result));\r\n            });\r\n\r\n            // Unbind transloadit from the form\r\n            elt.ownerTree._transloadit_bound = false;\r\n            formElt.unbind('submit.transloadit');\r\n\r\n            // Submit the form on next tick\r\n            langx.defer(function () {  //_.dalay\r\n              elt.ownerTree.submit();\r\n            }, 10);\r\n          },\r\n          onError: function (assembly) {\r\n            // TODO: report the error to the user\r\n            console.log('assembly error', assembly);\r\n          }\r\n        });\r\n      },\r\n      'onInsert': function (evt, node) {\r\n        $(node.el).find('a._jsonform-delete').on('click', function (evt) {\r\n          $(node.el).find('._jsonform-preview').remove();\r\n          $(node.el).find('a._jsonform-delete').remove();\r\n          $(node.el).find('#' + util.escapeSelector(node.id)).val('');\r\n          evt.preventDefault();\r\n          return false;\r\n        });\r\n      },\r\n      'onSubmit':function(evt, elt) {\r\n        if (elt.ownerTree._transloadit_bound) {\r\n          return false;\r\n        }\r\n        return true;\r\n      }\r\n\r\n    },\r\n    'file-transloadit': {\r\n      'template': '<span><% if (value && (value.type||value.url)) { %>'+fileDisplayTemplate+'<% } %><input class=\"input-file\" id=\"_transloadit_<%= id %>\" type=\"file\" name=\"_transloadit_<%= node.name %>\" /><input type=\"hidden\" id=\"<%= id %>\" name=\"<%= node.name %>\" value=\\'<%= escape(JSON.stringify(node.value)) %>\\' /></span>',\r\n      'fieldtemplate': true,\r\n      'inputfield': true,\r\n      'getElement': function (el) {\r\n        return $(el).parent().get(0);\r\n      },\r\n      'onChange': function (evt, elt) {\r\n        // The \"transloadit\" function should be called only once to enable\r\n        // the service when the form is submitted. Has it already been done?\r\n        if (elt.ownerTree._transloadit_bound) {\r\n          return false;\r\n        }\r\n        elt.ownerTree._transloadit_bound = true;\r\n\r\n        // Call the \"transloadit\" function on the form element\r\n        var formElt = $(elt.ownerTree.domRoot);\r\n        formElt.transloadit({\r\n          autoSubmit: false,\r\n          wait: true,\r\n          onSuccess: function (assembly) {\r\n            // Image has been uploaded. Check the \"results\" property that\r\n            // contains the list of files that Transloadit produced. Note\r\n            // JSONForm only supports 1-to-1 associations, meaning it\r\n            // expects the \"results\" property to contain only one image\r\n            // per file input in the form.\r\n            var results = langx.values(assembly.results);\r\n            results = langx.flatten(results);\r\n            util.each(results, function (result) {\r\n              // Save the assembly result in the right hidden input field\r\n              var input = formElt.find('input[name=\"' +\r\n                result.field.replace(/^_transloadit_/, '') +\r\n                '\"]');\r\n              var nonEmptyKeys = langx.filter(langx.keys(result.meta), function (key) {\r\n                return !!util.isSet(result.meta[key]);\r\n              });\r\n              result.meta = langx.pick(result.meta, nonEmptyKeys);\r\n              input.val(JSON.stringify(result));\r\n            });\r\n\r\n            // Unbind transloadit from the form\r\n            elt.ownerTree._transloadit_bound = false;\r\n            formElt.unbind('submit.transloadit');\r\n\r\n            // Submit the form on next tick\r\n            langx.defer(function () { //_.delay\r\n              elt.ownerTree.submit();\r\n            }, 10);\r\n          },\r\n          onError: function (assembly) {\r\n            // TODO: report the error to the user\r\n            console.log('assembly error', assembly);\r\n          }\r\n        });\r\n      },\r\n      'onInsert': function (evt, node) {\r\n        $(node.el).find('a._jsonform-delete').on('click', function (evt) {\r\n          $(node.el).find('._jsonform-preview').remove();\r\n          $(node.el).find('a._jsonform-delete').remove();\r\n          $(node.el).find('#' + util.escapeSelector(node.id)).val('');\r\n          evt.preventDefault();\r\n          return false;\r\n        });\r\n      },\r\n      'onSubmit': function (evt, elt) {\r\n        if (elt.ownerTree._transloadit_bound) {\r\n          return false;\r\n        }\r\n        return true;\r\n      }\r\n    },\r\n    'select':{\r\n      'template':'<select name=\"<%= node.name %>\" id=\"<%= id %>\"' +\r\n        'class=\\'form-control<%= (fieldHtmlClass ? \" \" + fieldHtmlClass : \"\") %>\\'' +\r\n        '<%= (node.schemaElement && node.schemaElement.disabled? \" disabled\" : \"\")%>' +\r\n        '<%= (node.schemaElement && node.schemaElement.required ? \" required=\\'required\\'\" : \"\") %>' +\r\n        '> ' +\r\n        '<% _.forEach(node.options, function(key, val) { if(key instanceof Object) { if (value === key.value) { %> <option selected value=\"<%= key.value %>\"><%= key.title %></option> <% } else { %> <option value=\"<%= key.value %>\"><%= key.title %></option> <% }} else { if (value === key) { %> <option selected value=\"<%= key %>\"><%= key %></option> <% } else { %><option value=\"<%= key %>\"><%= key %></option> <% }}}); %> ' +\r\n        '</select>',\r\n      'fieldtemplate': true,\r\n      'inputfield': true\r\n    },\r\n    'imageselect': {\r\n      'template': '<div>' +\r\n        '<input type=\"hidden\" name=\"<%= node.name %>\" id=\"<%= node.id %>\" value=\"<%= value %>\" />' +\r\n        '<div class=\"dropdown\">' +\r\n        '<a class=\"btn<% if (buttonClass && node.value) { %> <%= buttonClass %><% } else { %> btn-default<% } %>\" data-toggle=\"dropdown\" href=\"#\"<% if (node.value) { %> style=\"max-width:<%= width %>px;max-height:<%= height %>px\"<% } %>>' +\r\n          '<% if (node.value) { %><img src=\"<% if (!node.value.match(/^https?:/)) { %><%= prefix %><% } %><%= node.value %><%= suffix %>\" alt=\"\" /><% } else { %><%= buttonTitle %><% } %>' +\r\n        '</a>' +\r\n        '<div class=\"dropdown-menu navbar\" id=\"<%= node.id %>_dropdown\">' +\r\n          '<div>' +\r\n          '<% _.forEach(node.options, function(key, idx) { if ((idx > 0) && ((idx % columns) === 0)) { %></div><div><% } %><a class=\"btn<% if (buttonClass) { %> <%= buttonClass %><% } else { %> btn-default<% } %>\" style=\"max-width:<%= width %>px;max-height:<%= height %>px\"><% if (key instanceof Object) { %><img src=\"<% if (!key.value.match(/^https?:/)) { %><%= prefix %><% } %><%= key.value %><%= suffix %>\" alt=\"<%= key.title %>\" /></a><% } else { %><img src=\"<% if (!key.match(/^https?:/)) { %><%= prefix %><% } %><%= key %><%= suffix %>\" alt=\"\" /><% } %></a> <% }); %>' +\r\n          '</div>' +\r\n          '<div class=\"pagination-right\"><a class=\"btn btn-default\">Reset</a></div>' +\r\n        '</div>' +\r\n        '</div>' +\r\n        '</div>',\r\n      'fieldtemplate': true,\r\n      'inputfield': true,\r\n      'onBeforeRender': function (data, node) {\r\n        var elt = node.formElement || {};\r\n        var nbRows = null;\r\n        var maxColumns = elt.imageSelectorColumns || 5;\r\n        data.buttonTitle = elt.imageSelectorTitle || 'Select...';\r\n        data.prefix = elt.imagePrefix || '';\r\n        data.suffix = elt.imageSuffix || '';\r\n        data.width = elt.imageWidth || 32;\r\n        data.height = elt.imageHeight || 32;\r\n        data.buttonClass = elt.imageButtonClass || false;\r\n        if (node.options.length > maxColumns) {\r\n          nbRows = Math.ceil(node.options.length / maxColumns);\r\n          data.columns = Math.ceil(node.options.length / nbRows);\r\n        }\r\n        else {\r\n          data.columns = maxColumns;\r\n        }\r\n      },\r\n      'getElement': function (el) {\r\n        return $(el).parent().get(0);\r\n      },\r\n      'onInsert': function (evt, node) {\r\n        $(node.el).on('click', '.dropdown-menu a', function (evt) {\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n          var img = (evt.target.nodeName.toLowerCase() === 'img') ?\r\n            $(evt.target) :\r\n            $(evt.target).find('img');\r\n          var value = img.attr('src');\r\n          var elt = node.formElement || {};\r\n          var prefix = elt.imagePrefix || '';\r\n          var suffix = elt.imageSuffix || '';\r\n          var width = elt.imageWidth || 32;\r\n          var height = elt.imageHeight || 32;\r\n          if (value) {\r\n            if (value.indexOf(prefix) === 0) {\r\n              value = value.substring(prefix.length);\r\n            }\r\n            value = value.substring(0, value.length - suffix.length);\r\n            $(node.el).find('input').attr('value', value);\r\n            $(node.el).find('a[data-toggle=\"dropdown\"]')\r\n              .addClass(elt.imageButtonClass)\r\n              .attr('style', 'max-width:' + width + 'px;max-height:' + height + 'px')\r\n              .html('<img src=\"' + (!value.match(/^https?:/) ? prefix : '') + value + suffix + '\" alt=\"\" />');\r\n          }\r\n          else {\r\n            $(node.el).find('input').attr('value', '');\r\n            $(node.el).find('a[data-toggle=\"dropdown\"]')\r\n              .removeClass(elt.imageButtonClass)\r\n              .removeAttr('style')\r\n              .html(elt.imageSelectorTitle || 'Select...');\r\n          }\r\n        });\r\n      }\r\n    },\r\n    'iconselect': {\r\n      'template': '<div>' +\r\n        '<input type=\"hidden\" name=\"<%= node.name %>\" id=\"<%= node.id %>\" value=\"<%= value %>\" />' +\r\n        '<div class=\"dropdown\">' +\r\n        '<a class=\"btn<% if (buttonClass && node.value) { %> <%= buttonClass %><% } %>\" data-toggle=\"dropdown\" href=\"#\"<% if (node.value) { %> style=\"max-width:<%= width %>px;max-height:<%= height %>px\"<% } %>>' +\r\n          '<% if (node.value) { %><i class=\"icon-<%= node.value %>\" /><% } else { %><%= buttonTitle %><% } %>' +\r\n        '</a>' +\r\n        '<div class=\"dropdown-menu navbar\" id=\"<%= node.id %>_dropdown\">' +\r\n          '<div>' +\r\n          '<% _.forEach(node.options, function(key, idx) { if ((idx > 0) && ((idx % columns) === 0)) { %></div><div><% } %><a class=\"btn<% if (buttonClass) { %> <%= buttonClass %><% } %>\" ><% if (key instanceof Object) { %><i class=\"icon-<%= key.value %>\" alt=\"<%= key.title %>\" /></a><% } else { %><i class=\"icon-<%= key %>\" alt=\"\" /><% } %></a> <% }); %>' +\r\n          '</div>' +\r\n          '<div class=\"pagination-right\"><a class=\"btn\">Reset</a></div>' +\r\n        '</div>' +\r\n        '</div>' +\r\n        '</div>',\r\n      'fieldtemplate': true,\r\n      'inputfield': true,\r\n      'onBeforeRender': function (data, node) {\r\n        var elt = node.formElement || {};\r\n        var nbRows = null;\r\n        var maxColumns = elt.imageSelectorColumns || 5;\r\n        data.buttonTitle = elt.imageSelectorTitle || 'Select...';\r\n        data.buttonClass = elt.imageButtonClass || false;\r\n        if (node.options.length > maxColumns) {\r\n          nbRows = Math.ceil(node.options.length / maxColumns);\r\n          data.columns = Math.ceil(node.options.length / nbRows);\r\n        }\r\n        else {\r\n          data.columns = maxColumns;\r\n        }\r\n      },\r\n      'getElement': function (el) {\r\n        return $(el).parent().get(0);\r\n      },\r\n      'onInsert': function (evt, node) {\r\n        $(node.el).on('click', '.dropdown-menu a', function (evt) {\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n          var i = (evt.target.nodeName.toLowerCase() === 'i') ?\r\n            $(evt.target) :\r\n            $(evt.target).find('i');\r\n          var value = i.attr('class');\r\n          var elt = node.formElement || {};\r\n          if (value) {\r\n            value = value;\r\n            $(node.el).find('input').attr('value', value);\r\n            $(node.el).find('a[data-toggle=\"dropdown\"]')\r\n              .addClass(elt.imageButtonClass)\r\n              .html('<i class=\"'+ value +'\" alt=\"\" />');\r\n          }\r\n          else {\r\n            $(node.el).find('input').attr('value', '');\r\n            $(node.el).find('a[data-toggle=\"dropdown\"]')\r\n              .removeClass(elt.imageButtonClass)\r\n              .html(elt.imageSelectorTitle || 'Select...');\r\n          }\r\n        });\r\n      }\r\n    },\r\n    'radios':{\r\n      'template': '<div id=\"<%= node.id %>\"><% _.forEach(node.options, function(key, val) { %><div class=\"radio\"><label><input<%= (fieldHtmlClass ? \" class=\\'\" + fieldHtmlClass + \"\\'\": \"\") %> type=\"radio\" <% if (((key instanceof Object) && (value === key.value)) || (value === key)) { %> checked=\"checked\" <% } %> name=\"<%= node.name %>\" value=\"<%= (key instanceof Object ? key.value : key) %>\"' +\r\n        '<%= (node.disabled? \" disabled\" : \"\")%>' +\r\n        '<%= (node.schemaElement && node.schemaElement.required ? \" required=\\'required\\'\" : \"\") %>' +\r\n        '/><%= (key instanceof Object ? key.title : key) %></label></div> <% }); %></div>',\r\n      'fieldtemplate': true,\r\n      'inputfield': true\r\n    },\r\n    'radiobuttons': {\r\n      'template': '<div id=\"<%= node.id %>\">' +\r\n        '<% _.forEach(node.options, function(key, val) { %>' +\r\n          '<label class=\"btn btn-default <% if (((key instanceof Object) && (value === key.value)) || (value === key)) { %>active btn-success<% } %>\">' +\r\n          '<input<%= (fieldHtmlClass ? \" class=\\'\" + fieldHtmlClass + \"\\'\": \"\") %> type=\"radio\" style=\"position:absolute;left:-9999px;\" ' +\r\n          '<% if (((key instanceof Object) && (value === key.value)) || (value === key)) { %> checked=\"checked\" <% } %> name=\"<%= node.name %>\" value=\"<%= (key instanceof Object ? key.value : key) %>\" />' +\r\n          '<span><%= (key instanceof Object ? key.title : key) %></span></label> ' +\r\n          '<% }); %>' +\r\n        '</div>',\r\n      'fieldtemplate': true,\r\n      'inputfield': true,\r\n      'onInsert': function (evt, node) {\r\n        var activeClass = 'active';\r\n        var elt = node.formElement || {};\r\n        if (elt.activeClass) {\r\n          activeClass += ' ' + elt.activeClass;\r\n        }\r\n        $(node.el).find('label').on('click', function () {\r\n          $(this).parent().find('label').removeClass(activeClass);\r\n          $(this).addClass(activeClass);\r\n        });\r\n      }\r\n    },\r\n    'checkboxes':{\r\n      'template': '<div><%= choiceshtml %></div>',\r\n      'fieldtemplate': true,\r\n      'inputfield': true,\r\n      'onBeforeRender': function (data, node) {\r\n        // Build up choices from the enumeration list\r\n        var choices = null;\r\n        var choiceshtml = null;\r\n        var template = '<div class=\"checkbox\"><label>' +\r\n          '<input type=\"checkbox\" <% if (value) { %> checked=\"checked\" <% } %> name=\"<%= name %>\" value=\"1\"' +\r\n          '<%= (node.disabled? \" disabled\" : \"\")%>' +\r\n          '/><%= title %></label></div>';\r\n        if (!node || !node.schemaElement) return;\r\n\r\n        if (node.schemaElement.items) {\r\n          choices =\r\n            node.schemaElement.items[\"enum\"] ||\r\n            node.schemaElement.items[0][\"enum\"];\r\n        } else {\r\n          choices = node.schemaElement[\"enum\"];\r\n        }\r\n        if (!choices) return;\r\n\r\n        choiceshtml = '';\r\n        util.each(choices, function (choice, idx) {\r\n          choiceshtml += langx.template(template, util.fieldTemplateSettings)({\r\n            name: node.key + '[' + idx + ']',\r\n            value: langx.contains(node.value, choice),\r\n            title: util.hasOwnProperty(node.formElement.titleMap, choice) ? node.formElement.titleMap[choice] : choice,\r\n            node: node\r\n          });\r\n        });\r\n\r\n        data.choiceshtml = choiceshtml;\r\n      }\r\n    },\r\n    'array': {\r\n      'template': '<div id=\"<%= id %>\"><ul class=\"_jsonform-array-ul\" style=\"list-style-type:none;\"><%= children %></ul>' +\r\n        '<span class=\"_jsonform-array-buttons\">' +\r\n          '<a href=\"#\" class=\"btn btn-default _jsonform-array-addmore\"><i class=\"glyphicon glyphicon-plus-sign\" title=\"Add new\"></i></a> ' +\r\n          '<a href=\"#\" class=\"btn btn-default _jsonform-array-deletelast\"><i class=\"glyphicon glyphicon-minus-sign\" title=\"Delete last\"></i></a>' +\r\n        '</span>' +\r\n        '</div>',\r\n      'fieldtemplate': true,\r\n      'array': true,\r\n      'childTemplate': function (inner, enableDrag) {\r\n        if ($('').sortable) {\r\n          // Insert a \"draggable\" icon\r\n          // floating to the left of the main element\r\n          return '<li data-idx=\"<%= node.childPos %>\">' +\r\n            // only allow drag of children if enabled\r\n            (enableDrag ? '<span class=\"draggable line\"><i class=\"glyphicon glyphicon-list\" title=\"Move item\"></i></span>' : '') +\r\n            inner +\r\n            '</li>';\r\n        }\r\n        else {\r\n          return '<li data-idx=\"<%= node.childPos %>\">' +\r\n            inner +\r\n            '</li>';\r\n        }\r\n      },\r\n      'onInsert': function (evt, node) {\r\n        var $nodeid = $(node.el).find('#' + util.escapeSelector(node.id));\r\n        var boundaries = node.getArrayBoundaries();\r\n\r\n        // Switch two nodes in an array\r\n        var moveNodeTo = function (fromIdx, toIdx) {\r\n          // Note \"switchValuesWith\" extracts values from the DOM since field\r\n          // values are not synchronized with the tree data structure, so calls\r\n          // to render are needed at each step to force values down to the DOM\r\n          // before next move.\r\n          // TODO: synchronize field values and data structure completely and\r\n          // call render only once to improve efficiency.\r\n          if (fromIdx === toIdx) return;\r\n          var incr = (fromIdx < toIdx) ? 1: -1;\r\n          var i = 0;\r\n          var parentEl = $('> ul', $nodeid);\r\n          for (i = fromIdx; i !== toIdx; i += incr) {\r\n            node.children[i].switchValuesWith(node.children[i + incr]);\r\n            node.children[i].render(parentEl.get(0));\r\n            node.children[i + incr].render(parentEl.get(0));\r\n          }\r\n\r\n          // No simple way to prevent DOM reordering with jQuery UI Sortable,\r\n          // so we're going to need to move sorted DOM elements back to their\r\n          // origin position in the DOM ourselves (we switched values but not\r\n          // DOM elements)\r\n          var fromEl = $(node.children[fromIdx].el);\r\n          var toEl = $(node.children[toIdx].el);\r\n          fromEl.detach();\r\n          toEl.detach();\r\n          if (fromIdx < toIdx) {\r\n            if (fromIdx === 0) parentEl.prepend(fromEl);\r\n            else $(node.children[fromIdx-1].el).after(fromEl);\r\n            $(node.children[toIdx-1].el).after(toEl);\r\n          }\r\n          else {\r\n            if (toIdx === 0) parentEl.prepend(toEl);\r\n            else $(node.children[toIdx-1].el).after(toEl);\r\n            $(node.children[fromIdx-1].el).after(fromEl);\r\n          }\r\n        };\r\n\r\n        $('> span > a._jsonform-array-addmore', $nodeid).click(function (evt) {\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n          var idx = node.children.length;\r\n          if (boundaries.maxItems >= 0) {\r\n            if (node.children.length > boundaries.maxItems - 2) {\r\n              $nodeid.find('> span > a._jsonform-array-addmore')\r\n                .addClass('disabled');\r\n            }\r\n            if (node.children.length > boundaries.maxItems - 1) {\r\n              return false;\r\n            }\r\n          }\r\n          node.insertArrayItem(idx, $('> ul', $nodeid).get(0));\r\n          if ((boundaries.minItems <= 0) ||\r\n              ((boundaries.minItems > 0) &&\r\n                (node.children.length > boundaries.minItems - 1))) {\r\n            $nodeid.find('> span > a._jsonform-array-deletelast')\r\n              .removeClass('disabled');\r\n          }\r\n        });\r\n\r\n        //Simulate Users click to setup the form with its minItems\r\n        var curItems = $('> ul > li', $nodeid).length;\r\n        if ((boundaries.minItems > 0) &&\r\n            (curItems < boundaries.minItems)) {\r\n          for (var i = 0; i < (boundaries.minItems - 1) && ($nodeid.find('> ul > li').length < boundaries.minItems); i++) {\r\n            node.insertArrayItem(curItems, $nodeid.find('> ul').get(0));\r\n          }\r\n        }\r\n        if ((boundaries.minItems > 0) &&\r\n            (node.children.length <= boundaries.minItems)) {\r\n          $nodeid.find('> span > a._jsonform-array-deletelast')\r\n            .addClass('disabled');\r\n        }\r\n\r\n        $('> span > a._jsonform-array-deletelast', $nodeid).click(function (evt) {\r\n          var idx = node.children.length - 1;\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n          if (boundaries.minItems > 0) {\r\n            if (node.children.length < boundaries.minItems + 2) {\r\n              $nodeid.find('> span > a._jsonform-array-deletelast')\r\n                .addClass('disabled');\r\n            }\r\n            if (node.children.length <= boundaries.minItems) {\r\n              return false;\r\n            }\r\n          }\r\n          else if (node.children.length === 1) {\r\n            $nodeid.find('> span > a._jsonform-array-deletelast')\r\n              .addClass('disabled');\r\n          }\r\n          node.deleteArrayItem(idx);\r\n          if ((boundaries.maxItems >= 0) && (idx <= boundaries.maxItems - 1)) {\r\n            $nodeid.find('> span > a._jsonform-array-addmore')\r\n              .removeClass('disabled');\r\n          }\r\n        });\r\n\r\n        // only allow drag if default or enabled\r\n        if (!util.isSet(node.formElement.draggable) || node.formElement.draggable) {\r\n          if ($(node.el).sortable) {\r\n            $('> ul', $nodeid).sortable();\r\n            $('> ul', $nodeid).bind('sortstop', function (event, ui) {\r\n              var idx = $(ui.item).data('idx');\r\n              var newIdx = $(ui.item).index();\r\n              moveNodeTo(idx, newIdx);\r\n            });\r\n          }\r\n        }\r\n      }\r\n    },\r\n    'tabarray': {\r\n      'template': '<div id=\"<%= id %>\"><div class=\"tabbable tabs-left\">' +\r\n        '<ul class=\"nav nav-tabs\">' +\r\n          '<%= tabs %>' +\r\n        '</ul>' +\r\n        '<div class=\"tab-content\">' +\r\n          '<%= children %>' +\r\n        '</div>' +\r\n        '</div>' +\r\n        '<a href=\"#\" class=\"btn btn-default _jsonform-array-addmore\"><i class=\"glyphicon glyphicon-plus-sign\" title=\"Add new\"></i></a> ' +\r\n        '<a href=\"#\" class=\"btn btn-default _jsonform-array-deleteitem\"><i class=\"glyphicon glyphicon-minus-sign\" title=\"Delete item\"></i></a></div>',\r\n      'fieldtemplate': true,\r\n      'array': true,\r\n      'childTemplate': function (inner) {\r\n        return '<div data-idx=\"<%= node.childPos %>\" class=\"tab-pane\">' +\r\n          inner +\r\n          '</div>';\r\n      },\r\n      'onBeforeRender': function (data, node) {\r\n        // Generate the initial 'tabs' from the children\r\n        var tabs = '';\r\n        util.each(node.children, function (child, idx) {\r\n          var title = child.legend ||\r\n            child.title ||\r\n            ('Item ' + (idx+1));\r\n          tabs += '<li data-idx=\"' + idx + '\"' +\r\n            ((idx === 0) ? ' class=\"active\"' : '') +\r\n            '><a class=\"draggable tab\" data-toggle=\"tab\" rel=\"' + escape(title) + '\">' +\r\n            langx.escapeHTML(title) +\r\n            '</a></li>';\r\n        });\r\n        data.tabs = tabs;\r\n      },\r\n      'onInsert': function (evt, node) {\r\n        var $nodeid = $(node.el).find('#' + util.escapeSelector(node.id));\r\n        var boundaries = node.getArrayBoundaries();\r\n\r\n        var moveNodeTo = function (fromIdx, toIdx) {\r\n          // Note \"switchValuesWith\" extracts values from the DOM since field\r\n          // values are not synchronized with the tree data structure, so calls\r\n          // to render are needed at each step to force values down to the DOM\r\n          // before next move.\r\n          // TODO: synchronize field values and data structure completely and\r\n          // call render only once to improve efficiency.\r\n          if (fromIdx === toIdx) return;\r\n          var incr = (fromIdx < toIdx) ? 1: -1;\r\n          var i = 0;\r\n          var tabEl = $('> .tabbable > .tab-content', $nodeid).get(0);\r\n          for (i = fromIdx; i !== toIdx; i += incr) {\r\n            node.children[i].switchValuesWith(node.children[i + incr]);\r\n            node.children[i].render(tabEl);\r\n            node.children[i + incr].render(tabEl);\r\n          }\r\n        };\r\n\r\n\r\n        // Refreshes the list of tabs\r\n        var updateTabs = function (selIdx) {\r\n          var tabs = '';\r\n          var activateFirstTab = false;\r\n          if (selIdx === undefined) {\r\n            selIdx = $('> .tabbable > .nav-tabs .active', $nodeid).data('idx');\r\n            if (selIdx) {\r\n              selIdx = parseInt(selIdx, 10);\r\n            }\r\n            else {\r\n              activateFirstTab = true;\r\n              selIdx = 0;\r\n            }\r\n          }\r\n          if (selIdx >= node.children.length) {\r\n            selIdx = node.children.length - 1;\r\n          }\r\n          util.each(node.children, function (child, idx) {\r\n            $('> .tabbable > .tab-content > [data-idx=\"' + idx + '\"] > fieldset > legend', $nodeid).html(child.legend);\r\n            var title = child.legend || child.title || ('Item ' + (idx+1));\r\n            tabs += '<li data-idx=\"' + idx + '\">' +\r\n                    '<a class=\"draggable tab\" data-toggle=\"tab\" rel=\"' + escape(title) + '\">' +\r\n                    langx.escapeHTML(title) +\r\n                    '</a></li>';\r\n          });\r\n          $('> .tabbable > .nav-tabs', $nodeid).html(tabs);\r\n          if (activateFirstTab) {\r\n            $('> .tabbable > .nav-tabs [data-idx=\"0\"]', $nodeid).addClass('active');\r\n          }\r\n          $('> .tabbable > .nav-tabs [data-toggle=\"tab\"]', $nodeid).eq(selIdx).click();\r\n        };\r\n\r\n        $('> a._jsonform-array-deleteitem', $nodeid).click(function (evt) {\r\n          var idx = Number($('> .tabbable > .nav-tabs .active', $nodeid).data('idx'));\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n          if (boundaries.minItems > 0) {\r\n            if (node.children.length < boundaries.minItems + 1) {\r\n              $nodeid.find('> a._jsonform-array-deleteitem')\r\n                .addClass('disabled');\r\n            }\r\n            if (node.children.length <= boundaries.minItems) return false;\r\n          }\r\n          node.deleteArrayItem(idx);\r\n          updateTabs();\r\n          if ((node.children.length < boundaries.minItems + 1) ||\r\n              (node.children.length === 0)) {\r\n            $nodeid.find('> a._jsonform-array-deleteitem').addClass('disabled');\r\n          }\r\n          if ((boundaries.maxItems >= 0) &&\r\n              (node.children.length <= boundaries.maxItems)) {\r\n            $nodeid.find('> a._jsonform-array-addmore').removeClass('disabled');\r\n          }\r\n        });\r\n\r\n        $('> a._jsonform-array-addmore', $nodeid).click(function (evt) {\r\n          var idx = node.children.length;\r\n          if (boundaries.maxItems>=0) {\r\n            if (node.children.length>boundaries.maxItems-2) {\r\n              $('> a._jsonform-array-addmore', $nodeid).addClass(\"disabled\");\r\n            }\r\n            if (node.children.length > boundaries.maxItems - 1) {\r\n              return false;\r\n            }\r\n          }\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n          node.insertArrayItem(idx,\r\n            $nodeid.find('> .tabbable > .tab-content').get(0));\r\n          updateTabs(idx);\r\n          if ((boundaries.minItems <= 0) ||\r\n              ((boundaries.minItems > 0) && (idx > boundaries.minItems - 1))) {\r\n            $nodeid.find('> a._jsonform-array-deleteitem').removeClass('disabled');\r\n          }\r\n        });\r\n\r\n        $(node.el).on('legendUpdated', function (evt) {\r\n          updateTabs();\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n        });\r\n\r\n        // only allow drag if default or enabled\r\n        if (!util.isSet(node.formElement.draggable) || node.formElement.draggable) {\r\n          if ($(node.el).sortable) {\r\n            $('> .tabbable > .nav-tabs', $nodeid).sortable({\r\n              containment: node.el,\r\n              tolerance: 'pointer'\r\n            });\r\n            $('> .tabbable > .nav-tabs', $nodeid).bind('sortstop', function (event, ui) {\r\n              var idx = $(ui.item).data('idx');\r\n              var newIdx = $(ui.item).index();\r\n              moveNodeTo(idx, newIdx);\r\n              updateTabs(newIdx);\r\n            });\r\n          }\r\n        }\r\n\r\n        // Simulate User's click to setup the form with its minItems\r\n        if ((boundaries.minItems >= 0)  &&\r\n            (node.children.length <= boundaries.minItems)) {\r\n          for (var i = 0; i < (boundaries.minItems - 1); i++) {\r\n            $nodeid.find('> a._jsonform-array-addmore').click();\r\n          }\r\n          $nodeid.find('> a._jsonform-array-deleteitem').addClass('disabled');\r\n          updateTabs();\r\n        }\r\n\r\n        if ((boundaries.maxItems >= 0) &&\r\n            (node.children.length >= boundaries.maxItems)) {\r\n          $nodeid.find('> a._jsonform-array-addmore').addClass('disabled');\r\n        }\r\n        if ((boundaries.minItems >= 0) &&\r\n            (node.children.length <= boundaries.minItems)) {\r\n          $nodeid.find('> a._jsonform-array-deleteitem').addClass('disabled');\r\n        }\r\n      }\r\n    },\r\n    'help': {\r\n      'template':'<span class=\"help-block\" style=\"padding-top:5px\"><%= elt.helpvalue %></span>',\r\n      'fieldtemplate': true\r\n    },\r\n    'msg': {\r\n      'template': '<%= elt.msg %>'\r\n    },\r\n    'fieldset': {\r\n      'template': '<fieldset class=\"form-group jsonform-error-<%= keydash %> <% if (elt.expandable) { %>expandable<% } %> <%= elt.htmlClass?elt.htmlClass:\"\" %>\" ' +\r\n        '<% if (id) { %> id=\"<%= id %>\"<% } %>' +\r\n        '>' +\r\n        '<% if (node.title || node.legend) { %><legend role=\"treeitem\" aria-expanded=\"false\"><%= node.title || node.legend %></legend><% } %>' +\r\n        '<% if (elt.expandable) { %><div class=\"form-group\"><% } %>' +\r\n        '<%= children %>' +\r\n        '<% if (elt.expandable) { %></div><% } %>' +\r\n        '</fieldset>',\r\n      onInsert: function (evt, node) {\r\n        if (node.el !== null) {\r\n          $('.expandable > div, .expandable > fieldset', node.el).hide();\r\n          // See #233\r\n          $(\".expandable\", node.el).removeClass(\"expanded\");\r\n        }\r\n      }\r\n    },\r\n    'advancedfieldset': {\r\n      'template': '<fieldset' +\r\n        '<% if (id) { %> id=\"<%= id %>\"<% } %>' +\r\n        ' class=\"expandable <%= elt.htmlClass?elt.htmlClass:\"\" %>\">' +\r\n        '<legend role=\"treeitem\" aria-expanded=\"false\"><%= (node.title || node.legend) ? (node.title || node.legend) : \"Advanced options\" %></legend>' +\r\n        '<div class=\"form-group\">' +\r\n        '<%= children %>' +\r\n        '</div>' +\r\n        '</fieldset>',\r\n      onInsert: function (evt, node) {\r\n        if (node.el !== null) {\r\n          $('.expandable > div, .expandable > fieldset', node.el).hide();\r\n          // See #233\r\n          $(\".expandable\", node.el).removeClass(\"expanded\");\r\n        }\r\n      }\r\n    },\r\n    'authfieldset': {\r\n      'template': '<fieldset' +\r\n        '<% if (id) { %> id=\"<%= id %>\"<% } %>' +\r\n        ' class=\"expandable <%= elt.htmlClass?elt.htmlClass:\"\" %>\">' +\r\n        '<legend role=\"treeitem\" aria-expanded=\"false\"><%= (node.title || node.legend) ? (node.title || node.legend) : \"Authentication settings\" %></legend>' +\r\n        '<div class=\"form-group\">' +\r\n        '<%= children %>' +\r\n        '</div>' +\r\n        '</fieldset>',\r\n      onInsert: function (evt, node) {\r\n        if (node.el !== null) {\r\n          $('.expandable > div, .expandable > fieldset', node.el).hide();\r\n          // See #233\r\n          $(\".expandable\", node.el).removeClass(\"expanded\");\r\n        }\r\n      }\r\n    },\r\n    'submit':{\r\n      'template':'<input type=\"submit\" <% if (id) { %> id=\"<%= id %>\" <% } %> class=\"btn btn-primary <%= elt.htmlClass?elt.htmlClass:\"\" %>\" value=\"<%= value || node.title %>\"<%= (node.disabled? \" disabled\" : \"\")%>/>'\r\n    },\r\n    'button':{\r\n      'template':' <button type=\"button\" <% if (id) { %> id=\"<%= id %>\" <% } %> class=\"btn btn-default <%= elt.htmlClass?elt.htmlClass:\"\" %>\"><%= node.title %></button> '\r\n    },\r\n    'actions':{\r\n      'template':'<div class=\"<%= elt.htmlClass?elt.htmlClass:\"\" %>\"><%= children %></div>'\r\n    },\r\n    'hidden':{\r\n      'template':'<input type=\"hidden\" id=\"<%= id %>\" name=\"<%= node.name %>\" value=\"<%= escape(value) %>\" />',\r\n      'inputfield': true\r\n    },\r\n    'tabs':{\r\n      'template':'<ul class=\"nav nav-tabs <%= elt.htmlClass?elt.htmlClass:\"\" %>\"' +\r\n      '<% if (elt.id) { %> id=\"<%= elt.id %>\"<% } %>' +\r\n      '><%=tab_list%></ul><div class=\"tab-content\" <% if (elt.id) { %> data-tabset=\"<%= elt.id %>\"<% } %>><%=children%></div>',\r\n      'getElement': function (el) {\r\n        return $(el).parent().get(0);\r\n      },\r\n      'onBeforeRender': function (data, node) {\r\n        // Generate the initial 'tabs' from the children\r\n        var parentID = langx.escapeHTML(node.id ? node.id + \"-\" : \"\")\r\n        var tab_list = '';\r\n        util.each(node.children, function (child, idx) {\r\n          var title = langx.escapeHTML(child.title || ('Item ' + (idx+1)));\r\n          var title_escaped = title.replace(\" \",\"_\");\r\n          tab_list += '<li class=\"nav-item' +\r\n            ((idx === 0) ? ' active' : '') + '\">' +\r\n            '<a href=\"#'+ parentID + title_escaped +'\" class=\"nav-link\"' +\r\n            ' data-tab=\"' + parentID + title_escaped + '\"' +\r\n            ' data-toggle=\"tab\">' + title +\r\n            '</a></li>';\r\n        });\r\n        data.tab_list = tab_list;\r\n        return data;\r\n      },\r\n      'onInsert': function(evt, node){\r\n        $(\"#\"+node.id+\">li.nav-item\").on(\"click\", function(e){\r\n          e.preventDefault();\r\n          $(node.el).find(\"div[data-tabset='\"+node.id+\"']>div.tab-pane.active\").each(function(){\r\n            $(this).removeClass(\"active\");\r\n          })\r\n          var tab_id = $(this).find('a').attr('data-tab');\r\n          $(\"#\"+tab_id).addClass(\"active\");\r\n        });\r\n      }\r\n    },\r\n    'tab':{\r\n      'template': '<div class=\"tab-pane' +\r\n      '<% if (elt.htmlClass) { %> <%= elt.htmlClass %> <% } %>' +\r\n          //Set the first tab as active\r\n      '<% if (node.childPos === 0) { %> active<% } %>' +\r\n      '\"' + //Finish end quote of class tag\r\n      '<% if (node.title) { %> id=\"<%= node.parentNode.id %>-<%= node.title.replace(\" \",\"_\") %>\"<% } %>' +\r\n      '><%= children %></div>'\r\n    },\r\n    'selectfieldset': {\r\n      'template': '<fieldset class=\"tab-container <%= elt.htmlClass?elt.htmlClass:\"\" %>\">' +\r\n        '<% if (node.legend) { %><legend role=\"treeitem\" aria-expanded=\"false\"><%= node.legend %></legend><% } %>' +\r\n        '<% if (node.formElement.key) { %><input type=\"hidden\" id=\"<%= node.id %>\" name=\"<%= node.name %>\" value=\"<%= escape(value) %>\" /><% } else { %>' +\r\n          '<a id=\"<%= node.id %>\"></a><% } %>' +\r\n        '<div class=\"tabbable\">' +\r\n          '<div class=\"form-group<%= node.formElement.hideMenu ? \" hide\" : \"\" %>\">' +\r\n            '<% if (!elt.notitle) { %><label for=\"<%= node.id %>\"><%= node.title ? node.title : node.name %></label><% } %>' +\r\n            '<div class=\"controls\"><%= tabs %></div>' +\r\n          '</div>' +\r\n          '<div class=\"tab-content\">' +\r\n            '<%= children %>' +\r\n          '</div>' +\r\n        '</div>' +\r\n        '</fieldset>',\r\n      'inputfield': true,\r\n      'getElement': function (el) {\r\n        return $(el).parent().get(0);\r\n      },\r\n      'childTemplate': function (inner) {\r\n        return '<div data-idx=\"<%= node.childPos %>\" class=\"tab-pane' +\r\n          '<% if (node.active) { %> active<% } %>\">' +\r\n          inner +\r\n          '</div>';\r\n      },\r\n      'onBeforeRender': function (data, node) {\r\n        // Before rendering, this function ensures that:\r\n        // 1. direct children have IDs (used to show/hide the tabs contents)\r\n        // 2. the tab to active is flagged accordingly. The active tab is\r\n        // the first one, except if form values are available, in which case\r\n        // it's the first tab for which there is some value available (or back\r\n        // to the first one if there are none)\r\n        // 3. the HTML of the select field used to select tabs is exposed in the\r\n        // HTML template data as \"tabs\"\r\n\r\n        var children = null;\r\n        var choices = [];\r\n        if (node.schemaElement) {\r\n          choices = node.schemaElement['enum'] || [];\r\n        }\r\n        if (node.options) {\r\n          children = langx.map(node.options, function (option, idx) {\r\n            var child = node.children[idx];\r\n            child.childPos = idx; // When nested the childPos is always 0.\r\n            if (option instanceof Object) {\r\n              option = langx.extend({ node: child }, option);\r\n              option.title = option.title ||\r\n                child.legend ||\r\n                child.title ||\r\n                ('Option ' + (child.childPos+1));\r\n              option.value = util.isSet(option.value) ? option.value :\r\n                util.isSet(choices[idx]) ? choices[idx] : idx;\r\n              return option;\r\n            }\r\n            else {\r\n              return {\r\n                title: option,\r\n                value: util.isSet(choices[child.childPos]) ?\r\n                  choices[child.childPos] :\r\n                  child.childPos,\r\n                node: child\r\n              };\r\n            }\r\n          });\r\n        }\r\n        else {\r\n          children = langx.map(node.children, function (child, idx) {\r\n            child.childPos = idx; // When nested the childPos is always 0.\r\n            return {\r\n              title: child.legend || child.title || ('Option ' + (child.childPos+1)),\r\n              value: choices[child.childPos] || child.childPos,\r\n              node: child\r\n            };\r\n          });\r\n        }\r\n\r\n        // Reset each children to inactive so that they are not shown on insert\r\n        // The active one will then be shown later one. This is useful when sorting\r\n        // arrays with selectfieldset, otherwise both fields could be active at the\r\n        // same time.\r\n        util.each(children, function (child, idx) {\r\n          child.node.active = false\r\n        });\r\n\r\n        var activeChild = null;\r\n        if (data.value) {\r\n          activeChild = langx.find(children, function (child) {\r\n            return (child.value === node.value);\r\n          });\r\n        }\r\n        if (!activeChild) {\r\n          activeChild = langx.find(children, function (child) {\r\n            return child.node.hasNonDefaultValue();\r\n          });\r\n        }\r\n        if (!activeChild) {\r\n          activeChild = children[0];\r\n        }\r\n        activeChild.node.active = true;\r\n        data.value = activeChild.value;\r\n\r\n        var elt = node.formElement;\r\n        var tabs = '<select class=\"nav form-control\"' +\r\n          (node.disabled ? ' disabled' : '') +\r\n          '>';\r\n        util.each(children, function (child, idx) {\r\n          tabs += '<option data-idx=\"' + idx + '\" value=\"' + child.value + '\"' +\r\n            (child.node.active ? ' selected=\"selected\" class=\"active\"' : '') +\r\n            '>' +\r\n            langx.escapeHTML(child.title) +\r\n            '</option>';\r\n        });\r\n        tabs += '</select>';\r\n\r\n        data.tabs = tabs;\r\n        return data;\r\n      },\r\n      'onInsert': function (evt, node) {\r\n        $(node.el).find('select.nav').first().on('change', function (evt) {\r\n          var $option = $(this).find('option:selected');\r\n          $(node.el).find('input[type=\"hidden\"]').first().val($option.attr('value'));\r\n        });\r\n      }\r\n    },\r\n    'optionfieldset': {\r\n      'template': '<div' +\r\n        '<% if (node.id) { %> id=\"<%= node.id %>\"<% } %>' +\r\n        '>' +\r\n        '<%= children %>' +\r\n        '</div>'\r\n    },\r\n    'section': {\r\n      'template': '<div' +\r\n        '<% if (elt.htmlClass) { %> class=\"<%= elt.htmlClass %>\"<% } %>' +\r\n        '<% if (node.id) { %> id=\"<%= node.id %>\"<% } %>' +\r\n        '><%= children %></div>'\r\n    },\r\n\r\n    /**\r\n     * A \"questions\" field renders a series of question fields and binds the\r\n     * result to the value of a schema key.\r\n     */\r\n    'questions': {\r\n      'template': '<div>' +\r\n        '<input type=\"hidden\" id=\"<%= node.id %>\" name=\"<%= node.name %>\" value=\"<%= escape(value) %>\" />' +\r\n        '<%= children %>' +\r\n        '</div>',\r\n      'fieldtemplate': true,\r\n      'inputfield': true,\r\n      'getElement': function (el) {\r\n        return $(el).parent().get(0);\r\n      },\r\n      'onInsert': function (evt, node) {\r\n        if (!node.children || (node.children.length === 0)) return;\r\n        util.each(node.children, function (child) {\r\n          $(child.el).hide();\r\n        });\r\n        $(node.children[0].el).show();\r\n      }\r\n    },\r\n\r\n    /**\r\n     * A \"question\" field lets user choose a response among possible choices.\r\n     * The field is not associated with any schema key. A question should be\r\n     * part of a \"questions\" field that binds a series of questions to a\r\n     * schema key.\r\n     */\r\n    'question': {\r\n      'template': '<div id=\"<%= node.id %>\"><% _.forEach(node.options, function(key, val) { %><label class=\"<%= (node.formElement.optionsType === \"radiobuttons\") ? \"btn btn-default\" : \"\" %><%= ((key instanceof Object && key.htmlClass) ? \" \" + key.htmlClass : \"\") %>\"><input type=\"radio\" <% if (node.formElement.optionsType === \"radiobuttons\") { %> style=\"position:absolute;left:-9999px;\" <% } %>name=\"<%= node.id %>\" value=\"<%= val %>\"<%= (node.disabled? \" disabled\" : \"\")%>/><span><%= (key instanceof Object ? key.title : key) %></span></label> <% }); %></div>',\r\n      'fieldtemplate': true,\r\n      'onInsert': function (evt, node) {\r\n        var activeClass = 'active';\r\n        var elt = node.formElement || {};\r\n        if (elt.activeClass) {\r\n          activeClass += ' ' + elt.activeClass;\r\n        }\r\n\r\n        // Bind to change events on radio buttons\r\n        $(node.el).find('input[type=\"radio\"]').on('change', function (evt) {\r\n          var questionNode = null;\r\n          var option = node.options[$(this).val()];\r\n          if (!node.parentNode || !node.parentNode.el) return;\r\n\r\n          $(this).parent().parent().find('label').removeClass(activeClass);\r\n          $(this).parent().addClass(activeClass);\r\n          $(node.el).nextAll().hide();\r\n          $(node.el).nextAll().find('input[type=\"radio\"]').prop('checked', false);\r\n\r\n          // Execute possible actions (set key value, form submission, open link,\r\n          // move on to next question)\r\n          if (option.value) {\r\n            // Set the key of the 'Questions' parent\r\n            $(node.parentNode.el).find('input[type=\"hidden\"]').val(option.value);\r\n          }\r\n          if (option.next) {\r\n            questionNode = langx.find(node.parentNode.children, function (child) {\r\n              return (child.formElement && (child.formElement.qid === option.next));\r\n            });\r\n            $(questionNode.el).show();\r\n            $(questionNode.el).nextAll().hide();\r\n            $(questionNode.el).nextAll().find('input[type=\"radio\"]').prop('checked', false);\r\n          }\r\n          if (option.href) {\r\n            if (option.target) {\r\n              window.open(option.href, option.target);\r\n            }\r\n            else {\r\n              window.location = option.href;\r\n            }\r\n          }\r\n          if (option.submit) {\r\n            setTimeout(function () {\r\n              node.ownerTree.submit();\r\n            }, 0);\r\n          }\r\n        });\r\n      }\r\n    }\r\n  };\r\n\r\n  return jsonform.elementTypes;\r\n});\r\n\ndefine('skylark-jsonform/field-template',[\r\n  \"./jsonform\"\r\n],function(jsonform){\r\n  //210-245\r\n  // Twitter bootstrap-friendly HTML boilerplate for standard inputs\r\n  function fieldTemplate(inner) {\r\n    return '<div ' +\r\n      '<% for(var key in elt.htmlMetaData) {%>' +\r\n        '<%= key %>=\"<%= elt.htmlMetaData[key] %>\" ' +\r\n      '<% }%>' +\r\n      'class=\"form-group jsonform-error-<%= keydash %>' +\r\n      '<%= elt.htmlClass ? \" \" + elt.htmlClass : \"\" %>' +\r\n      '<%= (node.schemaElement && node.schemaElement.required && (node.schemaElement.type !== \"boolean\") ? \" jsonform-required\" : \"\") %>' +\r\n      '<%= (node.readOnly ? \" jsonform-readonly\" : \"\") %>' +\r\n      '<%= (node.disabled ? \" jsonform-disabled\" : \"\") %>' +\r\n      '\">' +\r\n      '<% if (!elt.notitle) { %>' +\r\n        '<label for=\"<%= node.id %>\"><%= node.title ? node.title : node.name %></label>' +\r\n      '<% } %>' +\r\n      '<div class=\"controls\">' +\r\n        '<% if (node.prepend || node.append) { %>' +\r\n        '<div class=\"<% if (node.prepend) { %>input-group<% } %>' +\r\n          '<% if (node.append) { %> input-group<% } %>\">' +\r\n          '<% if (node.prepend) { %>' +\r\n            '<span class=\"input-group-addon\"><%= node.prepend %></span>' +\r\n          '<% } %>' +\r\n        '<% } %>' +\r\n        inner +\r\n        '<% if (node.append) { %>' +\r\n          '<span class=\"input-group-addon\"><%= node.append %></span>' +\r\n        '<% } %>' +\r\n        '<% if (node.prepend || node.append) { %>' +\r\n          '</div>' +\r\n        '<% } %>' +\r\n        '<% if (node.description) { %>' +\r\n          '<span class=\"help-block\"><%= node.description %></span>' +\r\n        '<% } %>' +\r\n        '<span class=\"help-block jsonform-errortext\" style=\"display:none;\"></span>' +\r\n      '</div></div>';\r\n  }\r\n\r\n  return jsonform.fieldTemplate = fieldTemplate;\r\n});\r\n\ndefine('skylark-jsonform/form-node',[\r\n  \"skylark-langx-types\",\r\n  \"skylark-langx-objects\",\r\n  \"skylark-langx-funcs\",\r\n  \"skylark-langx-arrays\",\r\n  \"skylark-langx-strings\",\r\n  \"skylark-langx\",\r\n  \"skylark-jquery\",\r\n  \"./jsonform\",\r\n  \"./util\"\r\n],function(types,objects,funcs,arrays,strings,langx,$,jsonform,util){\r\n\r\n\r\n  //1686-1725\r\n  //1881-3097\r\n  /**\r\n   * Truncates the key path to the requested depth.\r\n   *\r\n   * For instance, if the key path is:\r\n   *  foo.bar[].baz.toto[].truc[].bidule\r\n   * and the requested depth is 1, the returned key will be:\r\n   *  foo.bar[].baz.toto\r\n   *\r\n   * Note the function includes the path up to the next depth level.\r\n   *\r\n   * @function\r\n   * @param {String} key The path to the key in the schema, each level being\r\n   *  separated by a dot and array items being flagged with [].\r\n   * @param {Number} depth The array depth\r\n   * @return {String} The path to the key truncated to the given depth.\r\n   */\r\n  var truncateToArrayDepth = function (key, arrayDepth) {\r\n    var depth = 0;\r\n    var pos = 0;\r\n    if (!key) return null;\r\n\r\n    if (arrayDepth > 0) {\r\n      while (depth < arrayDepth) {\r\n        pos = key.indexOf('[]', pos);\r\n        if (pos === -1) {\r\n          // Key path is not \"deep\" enough, simply return the full key\r\n          return key;\r\n        }\r\n        pos = pos + 2;\r\n        depth += 1;\r\n      }\r\n    }\r\n\r\n    // Move one step further to the right without including the final []\r\n    pos = key.indexOf('[]', pos);\r\n    if (pos === -1) return key;\r\n    else return key.substring(0, pos);\r\n  };\r\n\r\n\r\n  /**\r\n   * Represents a node in the form.\r\n   *\r\n   * Nodes that have an ID are linked to the corresponding DOM element\r\n   * when rendered\r\n   *\r\n   * Note the form element and the schema elements that gave birth to the\r\n   * node may be shared among multiple nodes (in the case of arrays).\r\n   *\r\n   * @class\r\n   */\r\n  var formNode = function () {\r\n    /**\r\n     * The node's ID (may not be set)\r\n     */\r\n    this.id = null;\r\n\r\n    /**\r\n     * The node's key path (may not be set)\r\n     */\r\n    this.key = null;\r\n\r\n    /**\r\n     * DOM element associated witht the form element.\r\n     *\r\n     * The DOM element is set when the form element is rendered.\r\n     */\r\n    this.el = null;\r\n\r\n    /**\r\n     * Link to the form element that describes the node's layout\r\n     * (note the form element is shared among nodes in arrays)\r\n     */\r\n    this.formElement = null;\r\n\r\n    /**\r\n     * Link to the schema element that describes the node's value constraints\r\n     * (note the schema element is shared among nodes in arrays)\r\n     */\r\n    this.schemaElement = null;\r\n\r\n    /**\r\n     * Pointer to the \"view\" associated with the node, typically the right\r\n     * object in jsonform.elementTypes\r\n     */\r\n    this.view = null;\r\n\r\n    /**\r\n     * Node's subtree (if one is defined)\r\n     */\r\n    this.children = [];\r\n\r\n    /**\r\n     * A pointer to the form tree the node is attached to\r\n     */\r\n    this.ownerTree = null;\r\n\r\n    /**\r\n     * A pointer to the parent node of the node in the tree\r\n     */\r\n    this.parentNode = null;\r\n\r\n    /**\r\n     * Child template for array-like nodes.\r\n     *\r\n     * The child template gets cloned to create new array items.\r\n     */\r\n    this.childTemplate = null;\r\n\r\n\r\n    /**\r\n     * Direct children of array-like containers may use the value of a\r\n     * specific input field in their subtree as legend. The link to the\r\n     * legend child is kept here and initialized in computeInitialValues\r\n     * when a child sets \"valueInLegend\"\r\n     */\r\n    this.legendChild = null;\r\n\r\n\r\n    /**\r\n     * The path of indexes that lead to the current node when the\r\n     * form element is not at the root array level.\r\n     *\r\n     * Note a form element may well be nested element and still be\r\n     * at the root array level. That's typically the case for \"fieldset\"\r\n     * elements. An array level only gets created when a form element\r\n     * is of type \"array\" (or a derivated type such as \"tabarray\").\r\n     *\r\n     * The array path of a form element linked to the foo[2].bar.baz[3].toto\r\n     * element in the submitted values is [2, 3] for instance.\r\n     *\r\n     * The array path is typically used to compute the right ID for input\r\n     * fields. It is also used to update positions when an array item is\r\n     * created, moved around or suppressed.\r\n     *\r\n     * @type {Array(Number)}\r\n     */\r\n    this.arrayPath = [];\r\n\r\n    /**\r\n     * Position of the node in the list of children of its parents\r\n     */\r\n    this.childPos = 0;\r\n  };\r\n\r\n\r\n  /**\r\n   * Clones a node\r\n   *\r\n   * @function\r\n   * @param {formNode} New parent node to attach the node to\r\n   * @return {formNode} Cloned node\r\n   */\r\n  formNode.prototype.clone = function (parentNode) {\r\n    var node = new formNode();\r\n    node.arrayPath = objects.clone(this.arrayPath);\r\n    node.ownerTree = this.ownerTree;\r\n    node.parentNode = parentNode || this.parentNode;\r\n    node.formElement = this.formElement;\r\n    node.schemaElement = this.schemaElement;\r\n    node.view = this.view;\r\n    node.children = arrays.map(this.children,function (child) { \r\n      return child.clone(node);\r\n    });\r\n    if (this.childTemplate) {\r\n      node.childTemplate = this.childTemplate.clone(node);\r\n    }\r\n    return node;\r\n  };\r\n\r\n\r\n  /**\r\n   * Returns true if the subtree that starts at the current node\r\n   * has some non empty value attached to it\r\n   */\r\n  formNode.prototype.hasNonDefaultValue = function () {\r\n\r\n    // hidden elements don't count because they could make the wrong selectfieldset element active\r\n    if (this.formElement && this.formElement.type==\"hidden\") {\r\n      return false;\r\n    }\r\n\r\n    if (this.value && !this.defaultValue) {\r\n      return true;\r\n    }\r\n    var child = this.children.find(function (child) { //_.find lwf\r\n      return child.hasNonDefaultValue();\r\n    });\r\n    return !!child;\r\n  };\r\n\r\n\r\n  /**\r\n   * Attaches a child node to the current node.\r\n   *\r\n   * The child node is appended to the end of the list.\r\n   *\r\n   * @function\r\n   * @param {formNode} node The child node to append\r\n   * @return {formNode} The inserted node (same as the one given as parameter)\r\n   */\r\n  formNode.prototype.appendChild = function (node) {\r\n    node.parentNode = this;\r\n    node.childPos = this.children.length;\r\n    this.children.push(node);\r\n    return node;\r\n  };\r\n\r\n\r\n  /**\r\n   * Removes the last child of the node.\r\n   *\r\n   * @function\r\n   */\r\n  formNode.prototype.removeChild = function () {\r\n    var child = this.children[this.children.length-1];\r\n    if (!child) return;\r\n\r\n    // Remove the child from the DOM\r\n    $(child.el).remove();\r\n\r\n    // Remove the child from the array\r\n    return this.children.pop();\r\n  };\r\n\r\n\r\n  /**\r\n   * Moves the user entered values set in the current node's subtree to the\r\n   * given node's subtree.\r\n   *\r\n   * The target node must follow the same structure as the current node\r\n   * (typically, they should have been generated from the same node template)\r\n   *\r\n   * The current node MUST be rendered in the DOM.\r\n   *\r\n   * TODO: when current node is not in the DOM, extract values from formNode.value\r\n   * properties, so that the function be available even when current node is not\r\n   * in the DOM.\r\n   *\r\n   * Moving values around allows to insert/remove array items at arbitrary\r\n   * positions.\r\n   *\r\n   * @function\r\n   * @param {formNode} node Target node.\r\n   */\r\n  formNode.prototype.moveValuesTo = function (node) {\r\n    var values = this.getFormValues(node.arrayPath);\r\n    node.resetValues();\r\n    node.computeInitialValues(values, true);\r\n  };\r\n\r\n\r\n  /**\r\n   * Switches nodes user entered values.\r\n   *\r\n   * The target node must follow the same structure as the current node\r\n   * (typically, they should have been generated from the same node template)\r\n   *\r\n   * Both nodes MUST be rendered in the DOM.\r\n   *\r\n   * TODO: update getFormValues to work even if node is not rendered, using\r\n   * formNode's \"value\" property.\r\n   *\r\n   * @function\r\n   * @param {formNode} node Target node\r\n   */\r\n  formNode.prototype.switchValuesWith = function (node) {\r\n    var values = this.getFormValues(node.arrayPath);\r\n    var nodeValues = node.getFormValues(this.arrayPath);\r\n    node.resetValues();\r\n    node.computeInitialValues(values, true);\r\n    this.resetValues();\r\n    this.computeInitialValues(nodeValues, true);\r\n  };\r\n\r\n\r\n  /**\r\n   * Resets all DOM values in the node's subtree.\r\n   *\r\n   * This operation also drops all array item nodes.\r\n   * Note values are not reset to their default values, they are rather removed!\r\n   *\r\n   * @function\r\n   */\r\n  formNode.prototype.resetValues = function () {\r\n    var params = null;\r\n    var idx = 0;\r\n\r\n    // Reset value\r\n    this.value = null;\r\n\r\n    // Propagate the array path from the parent node\r\n    // (adding the position of the child for nodes that are direct\r\n    // children of array-like nodes)\r\n    if (this.parentNode) {\r\n      this.arrayPath = objects.clone(this.parentNode.arrayPath);\r\n      if (this.parentNode.view && this.parentNode.view.array) {\r\n        this.arrayPath.push(this.childPos);\r\n      }\r\n    }\r\n    else {\r\n      this.arrayPath = [];\r\n    }\r\n\r\n    if (this.view && this.view.inputfield) {\r\n      // Simple input field, extract the value from the origin,\r\n      // set the target value and reset the origin value\r\n      params = $(':input', this.el).serializeArray();\r\n      util.each(params, function (param) {\r\n        // TODO: check this, there may exist corner cases with this approach\r\n        // (with multiple checkboxes for instance)\r\n        $('[name=\"' + util.escapeSelector(param.name) + '\"]', $(this.el)).val('');\r\n      }, this);\r\n    }\r\n    else if (this.view && this.view.array) {\r\n      // The current node is an array, drop all children\r\n      while (this.children.length > 0) {\r\n        this.removeChild();\r\n      }\r\n    }\r\n\r\n    // Recurse down the tree\r\n    util.each(this.children, function (child) {\r\n      child.resetValues();\r\n    });\r\n  };\r\n\r\n\r\n  /**\r\n   * Sets the child template node for the current node.\r\n   *\r\n   * The child template node is used to create additional children\r\n   * in an array-like form element. The template is never rendered.\r\n   *\r\n   * @function\r\n   * @param {formNode} node The child template node to set\r\n   */\r\n  formNode.prototype.setChildTemplate = function (node) {\r\n    this.childTemplate = node;\r\n    node.parentNode = this;\r\n  };\r\n\r\n\r\n  /**\r\n   * Recursively sets values to all nodes of the current subtree\r\n   * based on previously submitted values, or based on default\r\n   * values when the submitted values are not enough\r\n   *\r\n   * The function should be called once in the lifetime of a node\r\n   * in the tree. It expects its parent's arrayPath to be up to date.\r\n   *\r\n   * Three cases may arise:\r\n   * 1. if the form element is a simple input field, the value is\r\n   * extracted from previously submitted values of from default values\r\n   * defined in the schema.\r\n   * 2. if the form element is an array-like node, the child template\r\n   * is used to create as many children as possible (and at least one).\r\n   * 3. the function simply recurses down the node's subtree otherwise\r\n   * (this happens when the form element is a fieldset-like element).\r\n   *\r\n   * @function\r\n   * @param {Object} values Previously submitted values for the form\r\n   * @param {Boolean} ignoreDefaultValues Ignore default values defined in the\r\n   *  schema when set.\r\n   */\r\n  formNode.prototype.computeInitialValues = function (values, ignoreDefaultValues) {\r\n    var self = this;\r\n    var node = null;\r\n    var nbChildren = 1;\r\n    var i = 0;\r\n    var formData = this.ownerTree.formDesc.tpldata || {};\r\n\r\n    // Propagate the array path from the parent node\r\n    // (adding the position of the child for nodes that are direct\r\n    // children of array-like nodes)\r\n    if (this.parentNode) {\r\n      this.arrayPath = objects.clone(this.parentNode.arrayPath);\r\n      if (this.parentNode.view && this.parentNode.view.array) {\r\n        this.arrayPath.push(this.childPos);\r\n      }\r\n    }\r\n    else {\r\n      this.arrayPath = [];\r\n    }\r\n\r\n    // Prepare special data param \"idx\" for templated values\r\n    // (is is the index of the child in its wrapping array, starting\r\n    // at 1 since that's more human-friendly than a zero-based index)\r\n    formData.idx = (this.arrayPath.length > 0) ?\r\n      this.arrayPath[this.arrayPath.length-1] + 1 :\r\n      this.childPos + 1;\r\n\r\n    // Prepare special data param \"value\" for templated values\r\n    formData.value = '';\r\n\r\n    // Prepare special function to compute the value of another field\r\n    formData.getValue = function (key) {\r\n      if (!values) {\r\n        return '';\r\n      }\r\n      var returnValue = values;\r\n      var listKey = key.split('[].');\r\n      var i;\r\n      for (i = 0; i < listKey.length - 1; i++) {\r\n        returnValue = returnValue[listKey[i]][self.arrayPath[i]];\r\n      }\r\n      return returnValue[listKey[i]];\r\n    };\r\n\r\n    if (this.formElement) {\r\n      // Compute the ID of the field (if needed)\r\n      if (this.formElement.id) {\r\n        this.id = util.applyArrayPath(this.formElement.id, this.arrayPath);\r\n      }\r\n      else if (this.view && this.view.array) {\r\n        this.id = util.escapeSelector(this.ownerTree.formDesc.prefix) +\r\n          '-elt-counter-' + strings.uniqueId();\r\n      }\r\n      else if (this.parentNode && this.parentNode.view &&\r\n        this.parentNode.view.array) {\r\n        // Array items need an array to associate the right DOM element\r\n        // to the form node when the parent is rendered.\r\n        this.id = util.escapeSelector(this.ownerTree.formDesc.prefix) +\r\n          '-elt-counter-' + strings.uniqueId();\r\n      }\r\n      else if ((this.formElement.type === 'button') ||\r\n        (this.formElement.type === 'selectfieldset') ||\r\n        (this.formElement.type === 'question') ||\r\n        (this.formElement.type === 'buttonquestion')) {\r\n        // Buttons do need an id for \"onClick\" purpose\r\n        this.id =util.escapeSelector(this.ownerTree.formDesc.prefix) +\r\n          '-elt-counter-' + strings.uniqueId();\r\n      }\r\n\r\n      // Compute the actual key (the form element's key is index-free,\r\n      // i.e. it looks like foo[].bar.baz[].truc, so we need to apply\r\n      // the array path of the node to get foo[4].bar.baz[2].truc)\r\n      if (this.formElement.key) {\r\n        this.key = util.applyArrayPath(this.formElement.key, this.arrayPath);\r\n        this.keydash = util.slugify(this.key.replace(/\\./g, '---'));\r\n      }\r\n\r\n      // Same idea for the field's name\r\n      this.name = util.applyArrayPath(this.formElement.name, this.arrayPath);\r\n\r\n      // Consider that label values are template values and apply the\r\n      // form's data appropriately (note we also apply the array path\r\n      // although that probably doesn't make much sense for labels...)\r\n      util.each([\r\n        'title',\r\n        'legend',\r\n        'description',\r\n        'append',\r\n        'prepend',\r\n        'inlinetitle',\r\n        'helpvalue',\r\n        'value',\r\n        'disabled',\r\n        'placeholder',\r\n        'readOnly'\r\n      ],  (prop) => {\r\n        if (types.isString(this.formElement[prop])) {\r\n          if (this.formElement[prop].indexOf('{{values.') !== -1) {\r\n            // This label wants to use the value of another input field.\r\n            // Convert that construct into {{jsonform.getValue(key)}} for\r\n            // Underscore to call the appropriate function of formData\r\n            // when template gets called (note calling a function is not\r\n            // exactly Mustache-friendly but is supported by Underscore).\r\n            this[prop] = this.formElement[prop].replace(\r\n              /\\{\\{values\\.([^\\}]+)\\}\\}/g,\r\n              '{{getValue(\"$1\")}}');\r\n          }\r\n          else {\r\n            // Note applying the array path probably doesn't make any sense,\r\n            // but some geek might want to have a label \"foo[].bar[].baz\",\r\n            // with the [] replaced by the appropriate array path.\r\n            this[prop] = util.applyArrayPath(this.formElement[prop], this.arrayPath);\r\n          }\r\n          if (this[prop]) {\r\n            this[prop] = langx.template(this[prop], util.valueTemplateSettings)(formData);\r\n          }\r\n        }\r\n        else {\r\n          this[prop] = this.formElement[prop];\r\n        }\r\n      });\r\n\r\n      // Apply templating to options created with \"titleMap\" as well\r\n      if (this.formElement.options) {\r\n        this.options = arrays.map(this.formElement.options,function (option) { \r\n          var title = null;\r\n          if (types.isObject(option) && option.title) {\r\n            // See a few lines above for more details about templating\r\n            // preparation here.\r\n            if (option.title.indexOf('{{values.') !== -1) {\r\n              title = option.title.replace(\r\n                /\\{\\{values\\.([^\\}]+)\\}\\}/g,\r\n                '{{getValue(\"$1\")}}');\r\n            }\r\n            else {\r\n              title = util.applyArrayPath(option.title, self.arrayPath);\r\n            }\r\n            return objects.extend({}, option, {\r\n              value: (util.isSet(option.value) ? option.value : ''),\r\n              title: langx.template(title, util.valueTemplateSettings)(formData)\r\n            });\r\n          }\r\n          else {\r\n            return option;\r\n          }\r\n        });\r\n      }\r\n    }\r\n\r\n    if (this.view && this.view.inputfield && this.schemaElement) {\r\n      // Case 1: simple input field\r\n      if (values) {\r\n        // Form has already been submitted, use former value if defined.\r\n        // Note we won't set the field to its default value otherwise\r\n        // (since the user has already rejected it)\r\n        if (util.isSet(util.getObjKey(values, this.key))) {\r\n          this.value = util.getObjKey(values, this.key);\r\n        } else if (util.isSet(this.schemaElement['default'])) {\r\n          // the value is not provided in the values section but the\r\n          // default is set in the schemaElement (which we have)\r\n          this.value = this.schemaElement['default']\r\n          // We only apply a template if it's a string\r\n          if (typeof this.value === 'string') {\r\n            this.value = langx.template(this.value, util.valueTemplateSettings)(formData);\r\n          }\r\n\r\n        }\r\n      }\r\n      else if (!ignoreDefaultValues) {\r\n        // No previously submitted form result, use default value\r\n        // defined in the schema if it's available and not already\r\n        // defined in the form element\r\n        if (!util.isSet(this.value) && util.isSet(this.schemaElement['default'])) {\r\n          this.value = this.schemaElement['default'];\r\n          if (types.isString(this.value)) {\r\n            if (this.value.indexOf('{{values.') !== -1) {\r\n              // This label wants to use the value of another input field.\r\n              // Convert that construct into {{jsonform.getValue(key)}} for\r\n              // Underscore to call the appropriate function of formData\r\n              // when template gets called (note calling a function is not\r\n              // exactly Mustache-friendly but is supported by Underscore).\r\n              this.value = this.value.replace(\r\n                /\\{\\{values\\.([^\\}]+)\\}\\}/g,\r\n                '{{getValue(\"$1\")}}');\r\n            }\r\n            else {\r\n              // Note applying the array path probably doesn't make any sense,\r\n              // but some geek might want to have a label \"foo[].bar[].baz\",\r\n              // with the [] replaced by the appropriate array path.\r\n              this.value = util.applyArrayPath(this.value, this.arrayPath);\r\n            }\r\n            if (this.value) {\r\n              this.value = langx.template(this.value, util.valueTemplateSettings)(formData);\r\n            }\r\n          }\r\n          this.defaultValue = true;\r\n        }\r\n      }\r\n    }\r\n    else if (this.view && this.view.array) {\r\n      // Case 2: array-like node\r\n      nbChildren = 0;\r\n      if (values) {\r\n        nbChildren = this.getPreviousNumberOfItems(values, this.arrayPath);\r\n      }\r\n      // TODO: use default values at the array level when form has not been\r\n      // submitted before. Note it's not that easy because each value may\r\n      // be a complex structure that needs to be pushed down the subtree.\r\n      // The easiest way is probably to generate a \"values\" object and\r\n      // compute initial values from that object\r\n      /*\r\n      else if (this.schemaElement['default']) {\r\n        nbChildren = this.schemaElement['default'].length;\r\n      }\r\n      */\r\n      else if (nbChildren === 0) {\r\n        // If form has already been submitted with no children, the array\r\n        // needs to be rendered without children. If there are no previously\r\n        // submitted values, the array gets rendered with one empty item as\r\n        // it's more natural from a user experience perspective. That item can\r\n        // be removed with a click on the \"-\" button.\r\n        nbChildren = 1;\r\n      }\r\n      for (i = 0; i < nbChildren; i++) {\r\n        this.appendChild(this.childTemplate.clone());\r\n      }\r\n    }\r\n\r\n    // Case 3 and in any case: recurse through the list of children\r\n    util.each(this.children, function (child) {\r\n      child.computeInitialValues(values, ignoreDefaultValues);\r\n    });\r\n\r\n    // If the node's value is to be used as legend for its \"container\"\r\n    // (typically the array the node belongs to), ensure that the container\r\n    // has a direct link to the node for the corresponding tab.\r\n    if (this.formElement && this.formElement.valueInLegend) {\r\n      node = this;\r\n      while (node) {\r\n        if (node.parentNode &&\r\n          node.parentNode.view &&\r\n          node.parentNode.view.array) {\r\n          node.legendChild = this;\r\n          if (node.formElement && node.formElement.legend) {\r\n            node.legend = util.applyArrayPath(node.formElement.legend, node.arrayPath);\r\n            formData.idx = (node.arrayPath.length > 0) ?\r\n              node.arrayPath[node.arrayPath.length-1] + 1 :\r\n              node.childPos + 1;\r\n            formData.value = util.isSet(this.value) ? this.value : '';\r\n            node.legend = langx.template(node.legend, util.valueTemplateSettings)(formData);\r\n            break;\r\n          }\r\n        }\r\n        node = node.parentNode;\r\n      }\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Returns the number of items that the array node should have based on\r\n   * previously submitted values.\r\n   *\r\n   * The whole difficulty is that values may be hidden deep in the subtree\r\n   * of the node and may actually target different arrays in the JSON schema.\r\n   *\r\n   * @function\r\n   * @param {Object} values Previously submitted values\r\n   * @param {Array(Number)} arrayPath the array path we're interested in\r\n   * @return {Number} The number of items in the array\r\n   */\r\n  formNode.prototype.getPreviousNumberOfItems = function (values, arrayPath) {\r\n    var key = null;\r\n    var arrayValue = null;\r\n    var childNumbers = null;\r\n    var idx = 0;\r\n\r\n    if (!values) {\r\n      // No previously submitted values, no need to go any further\r\n      return 0;\r\n    }\r\n\r\n    if (this.view.inputfield && this.schemaElement) {\r\n      // Case 1: node is a simple input field that links to a key in the schema.\r\n      // The schema key looks typically like:\r\n      //  foo.bar[].baz.toto[].truc[].bidule\r\n      // The goal is to apply the array path and truncate the key to the last\r\n      // array we're interested in, e.g. with an arrayPath [4, 2]:\r\n      //  foo.bar[4].baz.toto[2]\r\n      key = truncateToArrayDepth(this.formElement.key, arrayPath.length);\r\n      key = util.applyArrayPath(key, arrayPath);\r\n      arrayValue = jsonform.util.getObjKey(values, key);\r\n      if (!arrayValue) {\r\n        // No key? That means this field had been left empty\r\n        // in previous submit\r\n        return 0;\r\n      }\r\n      childNumbers = arrays.map(this.children,function (child) {\r\n        return child.getPreviousNumberOfItems(values, arrayPath);\r\n      });\r\n      return util.max([util.max(childNumbers) || 0, arrayValue.length]);\r\n    }\r\n    else if (this.view.array) {\r\n      // Case 2: node is an array-like node, look for input fields\r\n      // in its child template\r\n      return this.childTemplate.getPreviousNumberOfItems(values, arrayPath);\r\n    }\r\n    else {\r\n      // Case 3: node is a leaf or a container,\r\n      // recurse through the list of children and return the maximum\r\n      // number of items found in each subtree\r\n      childNumbers = arrays.map(this.children,function (child) { \r\n        return child.getPreviousNumberOfItems(values, arrayPath);\r\n      });\r\n      return util.max(childNumbers) || 0;\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Returns the structured object that corresponds to the form values entered\r\n   * by the user for the node's subtree.\r\n   *\r\n   * The returned object follows the structure of the JSON schema that gave\r\n   * birth to the form.\r\n   *\r\n   * Obviously, the node must have been rendered before that function may\r\n   * be called.\r\n   *\r\n   * @function\r\n   * @param {Array(Number)} updateArrayPath Array path to use to pretend that\r\n   *  the entered values were actually entered for another item in an array\r\n   *  (this is used to move values around when an item is inserted/removed/moved\r\n   *  in an array)\r\n   * @return {Object} The object that follows the data schema and matches the\r\n   *  values entered by the user.\r\n   */\r\n  formNode.prototype.getFormValues = function (updateArrayPath) {\r\n    // The values object that will be returned\r\n    var values = {};\r\n\r\n    if (!this.el) {\r\n      throw new Error('formNode.getFormValues can only be called on nodes that are associated with a DOM element in the tree');\r\n    }\r\n\r\n    // Form fields values\r\n    var formArray = $(':input', this.el).serializeArray();\r\n\r\n    // Set values to false for unset checkboxes and radio buttons\r\n    // because serializeArray() ignores them\r\n    formArray = formArray.concat(\r\n      $(':input[type=checkbox]:not(:disabled):not(:checked)', this.el).map( function() {\r\n        return {\"name\": this.name, \"value\": this.checked}\r\n      }).get()\r\n    );\r\n\r\n    if (updateArrayPath) {\r\n      util.each(formArray, function (param) {\r\n        param.name = util.applyArrayPath(param.name, updateArrayPath);\r\n      });\r\n    }\r\n\r\n    // The underlying data schema\r\n    var formSchema = this.ownerTree.formDesc.schema;\r\n\r\n    for (var i = 0; i < formArray.length; i++) {\r\n      // Retrieve the key definition from the data schema\r\n      var name = formArray[i].name;\r\n      var eltSchema = util.getSchemaKey(formSchema.properties, name);\r\n      var arrayMatch = null;\r\n      var cval = null;\r\n\r\n      // Skip the input field if it's not part of the schema\r\n      if (!eltSchema) continue;\r\n\r\n      // Handle multiple checkboxes separately as the idea is to generate\r\n      // an array that contains the list of enumeration items that the user\r\n      // selected.\r\n      if (eltSchema._jsonform_checkboxes_as_array) {\r\n        arrayMatch = name.match(/\\[([0-9]*)\\]$/);\r\n        if (arrayMatch) {\r\n          name = name.replace(/\\[([0-9]*)\\]$/, '');\r\n          cval = jsonform.util.getObjKey(values, name) || [];\r\n          if (formArray[i].value === '1') {\r\n            // Value selected, push the corresponding enumeration item\r\n            // to the data result\r\n            cval.push(eltSchema['enum'][parseInt(arrayMatch[1],10)]);\r\n          }\r\n          jsonform.util.setObjKey(values, name, cval);\r\n          continue;\r\n        }\r\n      }\r\n\r\n      // Type casting\r\n      if (eltSchema.type === 'boolean') {\r\n        if (formArray[i].value === '0') {\r\n          formArray[i].value = false;\r\n        } else {\r\n          formArray[i].value = !!formArray[i].value;\r\n        }\r\n      }\r\n      if ((eltSchema.type === 'number') ||\r\n        (eltSchema.type === 'integer')) {\r\n        if (types.isString(formArray[i].value)) {\r\n          if (!formArray[i].value.length) {\r\n            formArray[i].value = null;\r\n          } else if (!isNaN(Number(formArray[i].value))) {\r\n            formArray[i].value = Number(formArray[i].value);\r\n          }\r\n        }\r\n      }\r\n      if ((eltSchema.type === 'string') &&\r\n        (formArray[i].value === '') &&\r\n        !eltSchema._jsonform_allowEmpty) {\r\n        formArray[i].value=null;\r\n      }\r\n      if ((eltSchema.type === 'object') &&\r\n        types.isString(formArray[i].value) &&\r\n        (formArray[i].value.substring(0,1) === '{')) {\r\n        try {\r\n          formArray[i].value = JSON.parse(formArray[i].value);\r\n        } catch (e) {\r\n          formArray[i].value = {};\r\n        }\r\n      }\r\n      //TODO: is this due to a serialization bug?\r\n      if ((eltSchema.type === 'object') &&\r\n        (formArray[i].value === 'null' || formArray[i].value === '')) {\r\n        formArray[i].value = null;\r\n      }\r\n\r\n      if (formArray[i].name && (formArray[i].value !== null)) {\r\n        jsonform.util.setObjKey(values, formArray[i].name, formArray[i].value);\r\n      }\r\n    }\r\n    return values;\r\n  };\r\n\r\n\r\n\r\n  /**\r\n   * Renders the node.\r\n   *\r\n   * Rendering is done in three steps: HTML generation, DOM element creation\r\n   * and insertion, and an enhance step to bind event handlers.\r\n   *\r\n   * @function\r\n   * @param {Node} el The DOM element where the node is to be rendered. The\r\n   *  node is inserted at the right position based on its \"childPos\" property.\r\n   */\r\n  formNode.prototype.render = function (el) {\r\n    var html = this.generate();\r\n    this.setContent(html, el);\r\n    this.enhance();\r\n  };\r\n\r\n\r\n  /**\r\n   * Inserts/Updates the HTML content of the node in the DOM.\r\n   *\r\n   * If the HTML is an update, the new HTML content replaces the old one.\r\n   * The new HTML content is not moved around in the DOM in particular.\r\n   *\r\n   * The HTML is inserted at the right position in its parent's DOM subtree\r\n   * otherwise (well, provided there are enough children, but that should always\r\n   * be the case).\r\n   *\r\n   * @function\r\n   * @param {string} html The HTML content to render\r\n   * @param {Node} parentEl The DOM element that is to contain the DOM node.\r\n   *  This parameter is optional (the node's parent is used otherwise) and\r\n   *  is ignored if the node to render is already in the DOM tree.\r\n   */\r\n  formNode.prototype.setContent = function (html, parentEl) {\r\n    var node = $(html);\r\n    var parentNode = parentEl ||\r\n      (this.parentNode ? this.parentNode.el : this.ownerTree.domRoot);\r\n    var nextSibling = null;\r\n\r\n    if (this.el) {\r\n      // Replace the contents of the DOM element if the node is already in the tree\r\n      $(this.el).replaceWith(node);\r\n    }\r\n    else {\r\n      // Insert the node in the DOM if it's not already there\r\n      nextSibling = $(parentNode).children().get(this.childPos);\r\n      if (nextSibling) {\r\n        $(nextSibling).before(node);\r\n      }\r\n      else {\r\n        $(parentNode).append(node);\r\n      }\r\n    }\r\n\r\n    // Save the link between the form node and the generated HTML\r\n    this.el = node;\r\n\r\n    // Update the node's subtree, extracting DOM elements that match the nodes\r\n    // from the generated HTML\r\n    this.updateElement(this.el);\r\n  };\r\n\r\n\r\n  /**\r\n   * Updates the DOM element associated with the node.\r\n   *\r\n   * Only nodes that have ID are directly associated with a DOM element.\r\n   *\r\n   * @function\r\n   */\r\n  formNode.prototype.updateElement = function (domNode) {\r\n    if (this.id) {\r\n      this.el = $('#' + util.escapeSelector(this.id), domNode).get(0);\r\n      if (this.view && this.view.getElement) {\r\n        this.el = this.view.getElement(this.el);\r\n      }\r\n      if ((this.fieldtemplate !== false) &&\r\n        this.view && this.view.fieldtemplate) {\r\n        // The field template wraps the element two or three level deep\r\n        // in the DOM tree, depending on whether there is anything prepended\r\n        // or appended to the input field\r\n        this.el = $(this.el).parent().parent();\r\n        if (this.prepend || this.prepend) {\r\n          this.el = this.el.parent();\r\n        }\r\n        this.el = this.el.get(0);\r\n      }\r\n      if (this.parentNode && this.parentNode.view &&\r\n        this.parentNode.view.childTemplate) {\r\n        // TODO: the child template may introduce more than one level,\r\n        // so the number of levels introduced should rather be exposed\r\n        // somehow in jsonform.fieldtemplate.\r\n        this.el = $(this.el).parent().get(0);\r\n      }\r\n    }\r\n\r\n    for (const k in  this.children) {\r\n       if (this.children.hasOwnProperty(k) == false) {\r\n           continue;\r\n       }\r\n       this.children[k].updateElement(this.el || domNode);\r\n   }\r\n  };\r\n\r\n\r\n  /**\r\n   * Generates the view's HTML content for the underlying model.\r\n   *\r\n   * @function\r\n   */\r\n  formNode.prototype.generate = function () {\r\n    var data = {\r\n      id: this.id,\r\n      keydash: this.keydash,\r\n      elt: this.formElement,\r\n      schema: this.schemaElement,\r\n      node: this,\r\n      value: util.isSet(this.value) ? this.value : '',\r\n      escape: strings.escapeHTML\r\n    };\r\n    var template = null;\r\n    var html = '';\r\n\r\n    // Complete the data context if needed\r\n    if (this.ownerTree.formDesc.onBeforeRender) {\r\n      this.ownerTree.formDesc.onBeforeRender(data, this);\r\n    }\r\n    if (this.view.onBeforeRender) {\r\n      this.view.onBeforeRender(data, this);\r\n    }\r\n\r\n    // Use the template that 'onBeforeRender' may have set,\r\n    // falling back to that of the form element otherwise\r\n    if (this.template) {\r\n      template = this.template;\r\n    }\r\n    else if (this.formElement && this.formElement.template) {\r\n      template = this.formElement.template;\r\n    }\r\n    else {\r\n      template = this.view.template;\r\n    }\r\n\r\n    // Wrap the view template in the generic field template\r\n    // (note the strict equality to 'false', needed as we fallback\r\n    // to the view's setting otherwise)\r\n    if ((this.fieldtemplate !== false) &&\r\n      (this.fieldtemplate || this.view.fieldtemplate)) {\r\n      template = jsonform.fieldTemplate(template);\r\n    }\r\n\r\n    // Wrap the content in the child template of its parent if necessary.\r\n    if (this.parentNode && this.parentNode.view &&\r\n      this.parentNode.view.childTemplate) {\r\n      // only allow drag of children if default or enabled\r\n      template = this.parentNode.view.childTemplate(template, (!util.isSet(this.parentNode.formElement.draggable) ? true : this.parentNode.formElement.draggable));\r\n    }\r\n\r\n    // Prepare the HTML of the children\r\n    var childrenhtml = '';\r\n    util.each(this.children, function (child) {\r\n      childrenhtml += child.generate();\r\n    });\r\n    data.children = childrenhtml;\r\n\r\n    data.fieldHtmlClass = '';\r\n    if (this.ownerTree &&\r\n        this.ownerTree.formDesc &&\r\n        this.ownerTree.formDesc.params &&\r\n        this.ownerTree.formDesc.params.fieldHtmlClass) {\r\n      data.fieldHtmlClass = this.ownerTree.formDesc.params.fieldHtmlClass;\r\n    }\r\n    if (this.formElement &&\r\n        (typeof this.formElement.fieldHtmlClass !== 'undefined')) {\r\n      data.fieldHtmlClass = this.formElement.fieldHtmlClass;\r\n    }\r\n\r\n    // Apply the HTML template\r\n    html = langx.template(template, util.fieldTemplateSettings)(data);\r\n    return html;\r\n  };\r\n\r\n\r\n  /**\r\n   * Enhances the view with additional logic, binding event handlers\r\n   * in particular.\r\n   *\r\n   * The function also runs the \"insert\" event handler of the view and\r\n   * form element if they exist (starting with that of the view)\r\n   *\r\n   * @function\r\n   */\r\n  formNode.prototype.enhance = function () {\r\n    var node = this;\r\n    var handlers = null;\r\n    var handler = null;\r\n    var formData = objects.clone(this.ownerTree.formDesc.tpldata) || {};\r\n\r\n    if (this.formElement) {\r\n      // Check the view associated with the node as it may define an \"onInsert\"\r\n      // event handler to be run right away\r\n      if (this.view.onInsert) {\r\n        this.view.onInsert({ target: $(this.el) }, this);\r\n      }\r\n\r\n      handlers = this.handlers || this.formElement.handlers;\r\n\r\n      // Trigger the \"insert\" event handler\r\n      handler = this.onInsert || this.formElement.onInsert;\r\n      if (handler) {\r\n        handler({ target: $(this.el) }, this);\r\n      }\r\n      if (handlers) {\r\n        util.each(handlers, function (handler, onevent) {\r\n          if (onevent === 'insert') {\r\n            handler({ target: $(this.el) }, this);\r\n          }\r\n        }, this);\r\n      }\r\n\r\n      // No way to register event handlers if the DOM element is unknown\r\n      // TODO: find some way to register event handlers even when this.el is not set.\r\n      if (this.el) {\r\n\r\n        // Register specific event handlers\r\n        // TODO: Add support for other event handlers\r\n        if (this.onChange)\r\n          $(this.el).bind('change', function(evt) { node.onChange(evt, node); });\r\n        if (this.view.onChange)\r\n          $(this.el).bind('change', function(evt) { node.view.onChange(evt, node); });\r\n        if (this.formElement.onChange)\r\n          $(this.el).bind('change', function(evt) { node.formElement.onChange(evt, node); });\r\n\r\n        if (this.onInput)\r\n          $(this.el).bind('input', function(evt) { node.onInput(evt, node); });\r\n        if (this.view.onInput)\r\n          $(this.el).bind('input', function(evt) { node.view.onInput(evt, node); });\r\n        if (this.formElement.onInput)\r\n          $(this.el).bind('input', function(evt) { node.formElement.onInput(evt, node); });\r\n\r\n        if (this.onClick)\r\n          $(this.el).bind('click', function(evt) { node.onClick(evt, node); });\r\n        if (this.view.onClick)\r\n          $(this.el).bind('click', function(evt) { node.view.onClick(evt, node); });\r\n        if (this.formElement.onClick)\r\n          $(this.el).bind('click', function(evt) { node.formElement.onClick(evt, node); });\r\n\r\n        if (this.onKeyUp)\r\n          $(this.el).bind('keyup', function(evt) { node.onKeyUp(evt, node); });\r\n        if (this.view.onKeyUp)\r\n          $(this.el).bind('keyup', function(evt) { node.view.onKeyUp(evt, node); });\r\n        if (this.formElement.onKeyUp)\r\n          $(this.el).bind('keyup', function(evt) { node.formElement.onKeyUp(evt, node); });\r\n\r\n        if (handlers) {\r\n          util.each(handlers, function (handler, onevent) {\r\n            if (onevent !== 'insert') {\r\n              $(this.el).bind(onevent, function(evt) { handler(evt, node); });\r\n            }\r\n          }, this);\r\n        }\r\n      }\r\n\r\n      // Auto-update legend based on the input field that's associated with it\r\n      if (this.legendChild && this.legendChild.formElement) {\r\n        var onChangeHandler = function (evt) {\r\n          if (node.formElement && node.formElement.legend && node.parentNode) {\r\n            node.legend = util.applyArrayPath(node.formElement.legend, node.arrayPath);\r\n            formData.idx = (node.arrayPath.length > 0) ?\r\n                node.arrayPath[node.arrayPath.length - 1] + 1 :\r\n                node.childPos + 1;\r\n            formData.value = $(evt.target).val();\r\n            node.legend = langx.template(node.legend, util.valueTemplateSettings)(formData);\r\n            $(node.parentNode.el).trigger('legendUpdated');\r\n          }\r\n        };\r\n        $(this.legendChild.el).bind('change', onChangeHandler);\r\n        $(this.legendChild.el).bind('keyup', onChangeHandler);\r\n      }\r\n    }\r\n\r\n    // Recurse down the tree to enhance children\r\n    util.each(this.children, function (child) {\r\n      child.enhance();\r\n    });\r\n  };\r\n\r\n\r\n\r\n  /**\r\n   * Inserts an item in the array at the requested position and renders the item.\r\n   *\r\n   * @function\r\n   * @param {Number} idx Insertion index\r\n   */\r\n  formNode.prototype.insertArrayItem = function (idx, domElement) {\r\n    var i = 0;\r\n\r\n    // Insert element at the end of the array if index is not given\r\n    if (idx === undefined) {\r\n      idx = this.children.length;\r\n    }\r\n\r\n    // Create the additional array item at the end of the list,\r\n    // using the item template created when tree was initialized\r\n    // (the call to resetValues ensures that 'arrayPath' is correctly set)\r\n    var child = this.childTemplate.clone();\r\n    this.appendChild(child);\r\n    child.resetValues();\r\n\r\n    // To create a blank array item at the requested position,\r\n    // shift values down starting at the requested position\r\n    // one to insert (note we start with the end of the array on purpose)\r\n    for (i = this.children.length-2; i >= idx; i--) {\r\n      this.children[i].moveValuesTo(this.children[i+1]);\r\n    }\r\n\r\n    // Initialize the blank node we've created with default values\r\n    this.children[idx].resetValues();\r\n    this.children[idx].computeInitialValues();\r\n\r\n    // Re-render all children that have changed\r\n    for (i = idx; i < this.children.length; i++) {\r\n      this.children[i].render(domElement);\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Remove an item from an array\r\n   *\r\n   * @function\r\n   * @param {Number} idx The index number of the item to remove\r\n   */\r\n  formNode.prototype.deleteArrayItem = function (idx) {\r\n    var i = 0;\r\n    var child = null;\r\n\r\n    // Delete last item if no index is given\r\n    if (idx === undefined) {\r\n      idx = this.children.length - 1;\r\n    }\r\n\r\n    // Move values up in the array\r\n    for (i = idx; i < this.children.length-1; i++) {\r\n      this.children[i+1].moveValuesTo(this.children[i]);\r\n      this.children[i].render();\r\n    }\r\n\r\n    // Remove the last array item from the DOM tree and from the form tree\r\n    this.removeChild();\r\n  };\r\n\r\n  /**\r\n   * Returns the minimum/maximum number of items that an array field\r\n   * is allowed to have according to the schema definition of the fields\r\n   * it contains.\r\n   *\r\n   * The function parses the schema definitions of the array items that\r\n   * compose the current \"array\" node and returns the minimum value of\r\n   * \"maxItems\" it encounters as the maximum number of items, and the\r\n   * maximum value of \"minItems\" as the minimum number of items.\r\n   *\r\n   * The function reports a -1 for either of the boundaries if the schema\r\n   * does not put any constraint on the number of elements the current\r\n   * array may have of if the current node is not an array.\r\n   *\r\n   * Note that array boundaries should be defined in the JSON Schema using\r\n   * \"minItems\" and \"maxItems\". The code also supports \"minLength\" and\r\n   * \"maxLength\" as a fallback, mostly because it used to by mistake (see #22)\r\n   * and because other people could make the same mistake.\r\n   *\r\n   * @function\r\n   * @return {Object} An object with properties \"minItems\" and \"maxItems\"\r\n   *  that reports the corresponding number of items that the array may\r\n   *  have (value is -1 when there is no constraint for that boundary)\r\n   */\r\n  formNode.prototype.getArrayBoundaries = function () {\r\n    var boundaries = {\r\n      minItems: -1,\r\n      maxItems: -1\r\n    };\r\n    if (!this.view || !this.view.array) return boundaries;\r\n\r\n    var getNodeBoundaries = function (node, initialNode) {\r\n      var schemaKey = null;\r\n      var arrayKey = null;\r\n      var boundaries = {\r\n        minItems: -1,\r\n        maxItems: -1\r\n      };\r\n      initialNode = initialNode || node;\r\n\r\n      if (node.view && node.view.array && (node !== initialNode)) {\r\n        // New array level not linked to an array in the schema,\r\n        // so no size constraints\r\n        return boundaries;\r\n      }\r\n\r\n      if (node.key) {\r\n        // Note the conversion to target the actual array definition in the\r\n        // schema where minItems/maxItems may be defined. If we're still looking\r\n        // at the initial node, the goal is to convert from:\r\n        //  foo[0].bar[3].baz to foo[].bar[].baz\r\n        // If we're not looking at the initial node, the goal is to look at the\r\n        // closest array parent:\r\n        //  foo[0].bar[3].baz to foo[].bar\r\n        arrayKey = node.key.replace(/\\[[0-9]+\\]/g, '[]');\r\n        if (node !== initialNode) {\r\n          arrayKey = arrayKey.replace(/\\[\\][^\\[\\]]*$/, '');\r\n        }\r\n        schemaKey = util.getSchemaKey(\r\n          node.ownerTree.formDesc.schema.properties,\r\n          arrayKey\r\n        );\r\n        if (!schemaKey) return boundaries;\r\n        return {\r\n          minItems: schemaKey.minItems || schemaKey.minLength || -1,\r\n          maxItems: schemaKey.maxItems || schemaKey.maxLength || -1\r\n        };\r\n      }\r\n      else {\r\n        util.each(node.children, function (child) {\r\n          var subBoundaries = getNodeBoundaries(child, initialNode);\r\n          if (subBoundaries.minItems !== -1) {\r\n            if (boundaries.minItems !== -1) {\r\n              boundaries.minItems = Math.max(\r\n                boundaries.minItems,\r\n                subBoundaries.minItems\r\n              );\r\n            }\r\n            else {\r\n              boundaries.minItems = subBoundaries.minItems;\r\n            }\r\n          }\r\n          if (subBoundaries.maxItems !== -1) {\r\n            if (boundaries.maxItems !== -1) {\r\n              boundaries.maxItems = Math.min(\r\n                boundaries.maxItems,\r\n                subBoundaries.maxItems\r\n              );\r\n            }\r\n            else {\r\n              boundaries.maxItems = subBoundaries.maxItems;\r\n            }\r\n          }\r\n        });\r\n      }\r\n      return boundaries;\r\n    };\r\n    return getNodeBoundaries(this);\r\n  };\r\n\r\n  return jsonform.formNode = formNode;\r\n});\r\n\r\n\ndefine('skylark-jsonform/form-tree',[\r\n  \"skylark-langx-globals\",\r\n  \"skylark-langx-types\",\r\n  \"skylark-langx-objects\",\r\n  \"skylark-langx-arrays\",\r\n  \"skylark-langx-strings\",\r\n  \"skylark-jquery\",\r\n  \"./jsonform\",\r\n  \"./util\",\r\n  \"./element-types\",\r\n  \"./form-node\"\r\n],function(globals,types,objects,arrays,strings,$,jsonform,util,elementTypes,formNode){\r\n  //3098-3649\r\n\r\n  /**\r\n   * Form tree class.\r\n   *\r\n   * Holds the internal representation of the form.\r\n   * The tree is always in sync with the rendered form, this allows to parse\r\n   * it easily.\r\n   *\r\n   * @class\r\n   */\r\n  var formTree = function () {\r\n    this.eventhandlers = [];\r\n    this.root = null;\r\n    this.formDesc = null;\r\n  };\r\n\r\n  /**\r\n   * Initializes the form tree structure from the JSONForm object\r\n   *\r\n   * This function is the main entry point of the JSONForm library.\r\n   *\r\n   * Initialization steps:\r\n   * 1. the internal tree structure that matches the JSONForm object\r\n   *  gets created (call to buildTree)\r\n   * 2. initial values are computed from previously submitted values\r\n   *  or from the default values defined in the JSON schema.\r\n   *\r\n   * When the function returns, the tree is ready to be rendered through\r\n   * a call to \"render\".\r\n   *\r\n   * @function\r\n   */\r\n  formTree.prototype.initialize = function (formDesc) {\r\n    formDesc = formDesc || {};\r\n\r\n    // Keep a pointer to the initial JSONForm\r\n    // (note clone returns a shallow copy, only first-level is cloned)\r\n    this.formDesc = objects.clone(formDesc);\r\n\r\n    this.formDesc.prefix = this.formDesc.prefix ||\r\n      'jsonform-' + strings.uniqueId();\r\n\r\n    // JSON schema shorthand\r\n    if (this.formDesc.schema && !this.formDesc.schema.properties) {\r\n      this.formDesc.schema = {\r\n        properties: this.formDesc.schema\r\n      };\r\n    }\r\n\r\n    // Ensure layout is set\r\n    this.formDesc.form = this.formDesc.form || [\r\n      '*',\r\n      {\r\n        type: 'actions',\r\n        items: [\r\n          {\r\n            type: 'submit',\r\n            value: 'Submit'\r\n          }\r\n        ]\r\n      }\r\n    ];\r\n    this.formDesc.form = (types.isArray(this.formDesc.form) ?\r\n      this.formDesc.form :\r\n      [this.formDesc.form]);\r\n\r\n    this.formDesc.params = this.formDesc.params || {};\r\n\r\n    // Create the root of the tree\r\n    this.root = new formNode();\r\n    this.root.ownerTree = this;\r\n    this.root.view = elementTypes['root'];\r\n\r\n    // Generate the tree from the form description\r\n    this.buildTree();\r\n\r\n    // Compute the values associated with each node\r\n    // (for arrays, the computation actually creates the form nodes)\r\n    this.computeInitialValues();\r\n  };\r\n\r\n\r\n  /**\r\n   * Constructs the tree from the form description.\r\n   *\r\n   * The function must be called once when the tree is first created.\r\n   *\r\n   * @function\r\n   */\r\n  formTree.prototype.buildTree = function () {\r\n    // Parse and generate the form structure based on the elements encountered:\r\n    // - '*' means \"generate all possible fields using default layout\"\r\n    // - a key reference to target a specific data element\r\n    // - a more complex object to generate specific form sections\r\n    util.each(this.formDesc.form,  (formElement) => {\r\n      if (formElement === '*') {\r\n        util.each(this.formDesc.schema.properties,  (element, key) => {\r\n          this.root.appendChild(this.buildFromLayout({\r\n            key: key\r\n          }));\r\n        });\r\n      }\r\n      else {\r\n        if (types.isString(formElement)) {\r\n          formElement = {\r\n            key: formElement\r\n          };\r\n        }\r\n        this.root.appendChild(this.buildFromLayout(formElement));\r\n      }\r\n    }, this);\r\n  };\r\n\r\n\r\n  /**\r\n   * Builds the internal form tree representation from the requested layout.\r\n   *\r\n   * The function is recursive, generating the node children as necessary.\r\n   * The function extracts the values from the previously submitted values\r\n   * (this.formDesc.value) or from default values defined in the schema.\r\n   *\r\n   * @function\r\n   * @param {Object} formElement JSONForm element to render\r\n   * @param {Object} context The parsing context (the array depth in particular)\r\n   * @return {Object} The node that matches the element.\r\n   */\r\n  formTree.prototype.buildFromLayout = function (formElement, context) {\r\n    var schemaElement = null;\r\n    var node = new formNode();\r\n    var view = null;\r\n    var key = null;\r\n\r\n    // The form element parameter directly comes from the initial\r\n    // JSONForm object. We'll make a shallow copy of it and of its children\r\n    // not to pollute the original object.\r\n    // (note JSON.parse(JSON.stringify()) cannot be used since there may be\r\n    // event handlers in there!)\r\n    formElement = objects.clone(formElement);\r\n    if (formElement.items) {\r\n      if (types.isArray(formElement.items)) {\r\n        formElement.items = arrays.map(formElement.items,objects.clone); \r\n      }\r\n      else {\r\n        formElement.items = [ objects.clone(formElement.items) ];\r\n      }\r\n    }\r\n\r\n    if (formElement.key) {\r\n      // The form element is directly linked to an element in the JSON\r\n      // schema. The properties of the form element override those of the\r\n      // element in the JSON schema. Properties from the JSON schema complete\r\n      // those of the form element otherwise.\r\n\r\n      // Retrieve the element from the JSON schema\r\n      schemaElement = util.getSchemaKey(\r\n        this.formDesc.schema.properties,\r\n        formElement.key);\r\n      if (!schemaElement) {\r\n        // The JSON Form is invalid!\r\n        throw new Error('The JSONForm object references the schema key \"' +\r\n          formElement.key + '\" but that key does not exist in the JSON schema');\r\n      }\r\n\r\n      // Schema element has just been found, let's trigger the\r\n      // \"onElementSchema\" event\r\n      // (tidoust: not sure what the use case for this is, keeping the\r\n      // code for backward compatibility)\r\n      if (this.formDesc.onElementSchema) {\r\n        this.formDesc.onElementSchema(formElement, schemaElement);\r\n      }\r\n\r\n      formElement.name =\r\n        formElement.name ||\r\n        formElement.key;\r\n      formElement.title =\r\n        formElement.title ||\r\n        schemaElement.title;\r\n      formElement.description =\r\n        formElement.description ||\r\n        schemaElement.description;\r\n      formElement.readOnly =\r\n        formElement.readOnly ||\r\n        schemaElement.readOnly ||\r\n        formElement.readonly ||\r\n        schemaElement.readonly;\r\n\r\n      // Compute the ID of the input field\r\n      if (!formElement.id) {\r\n        formElement.id = util.escapeSelector(this.formDesc.prefix) +\r\n          '-elt-' + util.slugify(formElement.key);\r\n      }\r\n\r\n      // Should empty strings be included in the final value?\r\n      // TODO: it's rather unclean to pass it through the schema.\r\n      if (formElement.allowEmpty) {\r\n        schemaElement._jsonform_allowEmpty = true;\r\n      }\r\n\r\n      // If the form element does not define its type, use the type of\r\n      // the schema element.\r\n      if (!formElement.type) {\r\n        // If schema type is an array containing only a type and \"null\",\r\n        // remove null and make the element non-required\r\n        if (types.isArray(schemaElement.type)) {\r\n          if (arrays.contains(schemaElement.type, \"null\")) {\r\n            schemaElement.type = arrays.without(schemaElement.type, \"null\");\r\n            schemaElement.required = false;\r\n          }\r\n          if (schemaElement.type.length > 1) {\r\n            throw new Error(\"Cannot process schema element with multiple types.\");\r\n          }\r\n          schemaElement.type = arrays.first(schemaElement.type);\r\n        }\r\n\r\n        if ((schemaElement.type === 'string') &&\r\n          (schemaElement.format === 'color')) {\r\n          formElement.type = 'color';\r\n        } else if ((schemaElement.type === 'number' ||\r\n          schemaElement.type === 'integer') &&\r\n          !schemaElement['enum']) {\r\n         formElement.type = 'number';\r\n         if (schemaElement.type === 'number') schemaElement.step = 'any';\r\n        } else if ((schemaElement.type === 'string' ||\r\n          schemaElement.type === 'any') &&\r\n          !schemaElement['enum']) {\r\n          formElement.type = 'text';\r\n        } else if (schemaElement.type === 'boolean') {\r\n          formElement.type = 'checkbox';\r\n        } else if (schemaElement.type === 'object') {\r\n          if (schemaElement.properties) {\r\n            formElement.type = 'fieldset';\r\n          } else {\r\n            formElement.type = 'textarea';\r\n          }\r\n        } else if (!types.isUndefined(schemaElement['enum'])) {\r\n          formElement.type = 'select';\r\n        } else {\r\n          formElement.type = schemaElement.type;\r\n        }\r\n      }\r\n\r\n      // Unless overridden in the definition of the form element (or unless\r\n      // there's a titleMap defined), use the enumeration list defined in\r\n      // the schema\r\n      if (!formElement.options && schemaElement['enum']) {\r\n        if (formElement.titleMap) {\r\n          formElement.options = arrays.map(schemaElement['enum'], function (value) {\r\n            return {\r\n              value: value,\r\n              title: util.hasOwnProperty(formElement.titleMap, value) ? formElement.titleMap[value] : value\r\n            };\r\n          });\r\n        }\r\n        else {\r\n          formElement.options = schemaElement['enum'];\r\n        }\r\n      }\r\n\r\n      // Flag a list of checkboxes with multiple choices\r\n      if ((formElement.type === 'checkboxes') && schemaElement.items) {\r\n        var itemsEnum = schemaElement.items['enum'];\r\n        if (itemsEnum) {\r\n          schemaElement.items._jsonform_checkboxes_as_array = true;\r\n        }\r\n        if (!itemsEnum && schemaElement.items[0]) {\r\n          itemsEnum = schemaElement.items[0]['enum'];\r\n          if (itemsEnum) {\r\n            schemaElement.items[0]._jsonform_checkboxes_as_array = true;\r\n          }\r\n        }\r\n      }\r\n\r\n      // If the form element targets an \"object\" in the JSON schema,\r\n      // we need to recurse through the list of children to create an\r\n      // input field per child property of the object in the JSON schema\r\n      if (schemaElement.type === 'object') {\r\n        util.each(schemaElement.properties, (prop, propName) => {\r\n          node.appendChild(this.buildFromLayout({\r\n            key: formElement.key + '.' + propName\r\n          }));\r\n        });\r\n      }\r\n    }\r\n\r\n    if (!formElement.type) {\r\n      formElement.type = 'none';\r\n    }\r\n    view = elementTypes[formElement.type];\r\n    if (!view) {\r\n      throw new Error('The JSONForm contains an element whose type is unknown: \"' +\r\n        formElement.type + '\"');\r\n    }\r\n\r\n\r\n    if (schemaElement) {\r\n      // The form element is linked to an element in the schema.\r\n      // Let's make sure the types are compatible.\r\n      // In particular, the element must not be a \"container\"\r\n      // (or must be an \"object\" or \"array\" container)\r\n      if (!view.inputfield && !view.array &&\r\n        (formElement.type !== 'selectfieldset') &&\r\n        (schemaElement.type !== 'object')) {\r\n        throw new Error('The JSONForm contains an element that links to an ' +\r\n          'element in the JSON schema (key: \"' + formElement.key + '\") ' +\r\n          'and that should not based on its type (\"' + formElement.type + '\")');\r\n      }\r\n    }\r\n    else {\r\n      // The form element is not linked to an element in the schema.\r\n      // This means the form element must be a \"container\" element,\r\n      // and must not define an input field.\r\n      if (view.inputfield && (formElement.type !== 'selectfieldset')) {\r\n        throw new Error('The JSONForm defines an element of type ' +\r\n          '\"' + formElement.type + '\" ' +\r\n          'but no \"key\" property to link the input field to the JSON schema');\r\n      }\r\n    }\r\n\r\n    // A few characters need to be escaped to use the ID as jQuery selector\r\n    formElement.iddot = util.escapeSelector(formElement.id || '');\r\n\r\n    // Initialize the form node from the form element and schema element\r\n    node.formElement = formElement;\r\n    node.schemaElement = schemaElement;\r\n    node.view = view;\r\n    node.ownerTree = this;\r\n\r\n    // Set event handlers\r\n    if (!formElement.handlers) {\r\n      formElement.handlers = {};\r\n    }\r\n\r\n    // Parse children recursively\r\n    if (node.view.array) {\r\n      // The form element is an array. The number of items in an array\r\n      // is by definition dynamic, up to the form user (through \"Add more\",\r\n      // \"Delete\" commands). The positions of the items in the array may\r\n      // also change over time (through \"Move up\", \"Move down\" commands).\r\n      //\r\n      // The form node stores a \"template\" node that serves as basis for\r\n      // the creation of an item in the array.\r\n      //\r\n      // Array items may be complex forms themselves, allowing for nesting.\r\n      //\r\n      // The initial values set the initial number of items in the array.\r\n      // Note a form element contains at least one item when it is rendered.\r\n      if (formElement.items) {\r\n        key = formElement.items[0] || formElement.items;\r\n      }\r\n      else {\r\n        key = formElement.key + '[]';\r\n      }\r\n      if (types.isString(key)) {\r\n        key = { key: key };\r\n      }\r\n      node.setChildTemplate(this.buildFromLayout(key));\r\n    }\r\n    else if (formElement.items) {\r\n      // The form element defines children elements\r\n      util.each(formElement.items, (item)=>{\r\n        if (types.isString(item)) {\r\n          item = { key: item };\r\n        }\r\n        node.appendChild(this.buildFromLayout(item));\r\n      });\r\n    }\r\n\r\n    return node;\r\n  };\r\n\r\n\r\n  /**\r\n   * Computes the values associated with each input field in the tree based\r\n   * on previously submitted values or default values in the JSON schema.\r\n   *\r\n   * For arrays, the function actually creates and inserts additional\r\n   * nodes in the tree based on previously submitted values (also ensuring\r\n   * that the array has at least one item).\r\n   *\r\n   * The function sets the array path on all nodes.\r\n   * It should be called once in the lifetime of a form tree right after\r\n   * the tree structure has been created.\r\n   *\r\n   * @function\r\n   */\r\n  formTree.prototype.computeInitialValues = function () {\r\n    this.root.computeInitialValues(this.formDesc.value);\r\n  };\r\n\r\n\r\n  /**\r\n   * Renders the form tree\r\n   *\r\n   * @function\r\n   * @param {Node} domRoot The \"form\" element in the DOM tree that serves as\r\n   *  root for the form\r\n   */\r\n  formTree.prototype.render = function (domRoot) {\r\n    if (!domRoot) return;\r\n    this.domRoot = domRoot;\r\n    this.root.render();\r\n\r\n    // If the schema defines required fields, flag the form with the\r\n    // \"jsonform-hasrequired\" class for styling purpose\r\n    // (typically so that users may display a legend)\r\n    if (this.hasRequiredField()) {\r\n      $(domRoot).addClass('jsonform-hasrequired');\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Walks down the element tree with a callback\r\n   *\r\n   * @function\r\n   * @param {Function} callback The callback to call on each element\r\n   */\r\n  formTree.prototype.forEachElement = function (callback) {\r\n\r\n    var f = function(root) {\r\n      for (var i=0;i<root.children.length;i++) {\r\n        callback(root.children[i]);\r\n        f(root.children[i]);\r\n      }\r\n    };\r\n    f(this.root);\r\n\r\n  };\r\n\r\n  formTree.prototype.validate = function(noErrorDisplay) {\r\n\r\n    var values = jsonform.getFormValue(this.domRoot);\r\n    var errors = false;\r\n\r\n    var options = this.formDesc;\r\n\r\n    if (options.validate!==false) {\r\n      var validator = false;\r\n      if (typeof options.validate!=\"object\") {\r\n        if (globals.JSONFormValidator) {\r\n          validator = globals.JSONFormValidator.createEnvironment(\"json-schema-draft-03\");\r\n        }\r\n      } else {\r\n        validator = options.validate;\r\n      }\r\n      if (validator) {\r\n        var v = validator.validate(values, this.formDesc.schema);\r\n        $(this.domRoot).jsonFormErrors(false,options);\r\n        if (v.errors.length) {\r\n          if (!errors) errors = [];\r\n          errors = errors.concat(v.errors);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (errors && !noErrorDisplay) {\r\n      if (options.displayErrors) {\r\n        options.displayErrors(errors,this.domRoot);\r\n      } else {\r\n        $(this.domRoot).jsonFormErrors(errors,options);\r\n      }\r\n    }\r\n\r\n    return {\"errors\":errors}\r\n\r\n  }\r\n\r\n  formTree.prototype.submit = function(evt) {\r\n\r\n    var stopEvent = function() {\r\n      if (evt) {\r\n        evt.preventDefault();\r\n        evt.stopPropagation();\r\n      }\r\n      return false;\r\n    };\r\n    var values = jsonform.getFormValue(this.domRoot);\r\n    var options = this.formDesc;\r\n\r\n    var brk=false;\r\n    this.forEachElement(function(elt) {\r\n      if (brk) return;\r\n      if (elt.view.onSubmit) {\r\n        brk = !elt.view.onSubmit(evt, elt); //may be called multiple times!!\r\n      }\r\n    });\r\n\r\n    if (brk) return stopEvent();\r\n\r\n    var validated = this.validate();\r\n\r\n    if (options.onSubmit && !options.onSubmit(validated.errors,values)) {\r\n      return stopEvent();\r\n    }\r\n\r\n    if (validated.errors) return stopEvent();\r\n\r\n    if (options.onSubmitValid && !options.onSubmitValid(values)) {\r\n      return stopEvent();\r\n    }\r\n\r\n    return false;\r\n\r\n  };\r\n\r\n\r\n  /**\r\n   * Returns true if the form displays a \"required\" field.\r\n   *\r\n   * To keep things simple, the function parses the form's schema and returns\r\n   * true as soon as it finds a \"required\" flag even though, in theory, that\r\n   * schema key may not appear in the final form.\r\n   *\r\n   * Note that a \"required\" constraint on a boolean type is always enforced,\r\n   * the code skips such definitions.\r\n   *\r\n   * @function\r\n   * @return {boolean} True when the form has some required field,\r\n   *  false otherwise.\r\n   */\r\n  formTree.prototype.hasRequiredField = function () {\r\n    var parseElement = function (element) {\r\n      if (!element) return null;\r\n      if (element.required && (element.type !== 'boolean')) {\r\n        return element;\r\n      }\r\n\r\n      var prop = arrays.find(element.properties, function (property) {\r\n        return parseElement(property);\r\n      });\r\n      if (prop) {\r\n        return prop;\r\n      }\r\n\r\n      if (element.items) {\r\n        if (types.isArray(element.items)) {\r\n          prop = arrays.find(element.items, function (item) {\r\n            return parseElement(item);\r\n          });\r\n        }\r\n        else {\r\n          prop = parseElement(element.items);\r\n        }\r\n        if (prop) {\r\n          return prop;\r\n        }\r\n      }\r\n    };\r\n\r\n    return parseElement(this.formDesc.schema);\r\n  };\r\n\r\n\r\n  return jsonform.formTree = formTree;\r\n\r\n});\r\n\ndefine('skylark-jsonform/get-form-value',[\r\n  \"skylark-jquery\",\r\n  \"./jsonform\"\r\n],function($,jsonform){\r\n\r\n\r\n\t//3652-3667\r\n\t/**\r\n\t * Returns the structured object that corresponds to the form values entered\r\n\t * by the use for the given form.\r\n\t *\r\n\t * The form must have been previously rendered through a call to jsonform.\r\n\t *\r\n\t * @function\r\n\t * @param {Node} The <form> tag in the DOM\r\n\t * @return {Object} The object that follows the data schema and matches the\r\n\t *  values entered by the user.\r\n\t */\r\n\tjsonform.getFormValue = function (formelt) {\r\n\t  var form = $(formelt).data('jsonform-tree');\r\n\t  if (!form) return null;\r\n\t  return form.root.getFormValues();\r\n\t};\r\n\r\n\treturn jsonform.getFormValue;\r\n});\ndefine('skylark-jsonform/fn',[\r\n  \"skylark-langx\",\r\n  \"skylark-jquery\",\r\n  \"./form-tree\",\r\n  \"./get-form-value\"\r\n],function(langx,$,formTree,getFormValue) {\r\n\r\n\r\n  /**\r\n   * Initializes tabular sections in forms. Such sections are generated by the\r\n   * 'selectfieldset' type of elements in JSON Form.\r\n   *\r\n   * Input fields that are not visible are automatically disabled\r\n   * not to appear in the submitted form. That's on purpose, as tabs\r\n   * are meant to convey an alternative (and not a sequence of steps).\r\n   *\r\n   * The tabs menu is not rendered as tabs but rather as a select field because\r\n   * it's easier to grasp that it's an alternative.\r\n   *\r\n   * Code based on bootstrap-tabs.js, updated to:\r\n   * - react to option selection instead of tab click\r\n   * - disable input fields in non visible tabs\r\n   * - disable the possibility to have dropdown menus (no meaning here)\r\n   * - act as a regular function instead of as a jQuery plug-in.\r\n   *\r\n   * @function\r\n   * @param {Object} tabs jQuery object that contains the tabular sections\r\n   *  to initialize. The object may reference more than one element.\r\n   */\r\n  var initializeTabs = function (tabs) {\r\n    var activate = function (element, container) {\r\n      container\r\n        .find('> .active')\r\n        .removeClass('active');\r\n      element.addClass('active');\r\n    };\r\n\r\n    var enableFields = function ($target, targetIndex) {\r\n      // Enable all fields in the targeted tab\r\n      $target.find('input, textarea, select').removeAttr('disabled');\r\n\r\n      // Disable all fields in other tabs\r\n      $target.parent()\r\n        .children(':not([data-idx=' + targetIndex + '])')\r\n        .find('input, textarea, select')\r\n        .attr('disabled', 'disabled');\r\n    };\r\n\r\n    var optionSelected = function (e) {\r\n      var $option = $(\"option:selected\", $(this)),\r\n        $select = $(this),\r\n        // do not use .attr() as it sometimes unexplicably fails\r\n        targetIdx = $option.get(0).getAttribute('data-idx') || $option.attr('value'),\r\n        $target;\r\n\r\n      e.preventDefault();\r\n      if ($option.hasClass('active')) {\r\n        return;\r\n      }\r\n\r\n      $target = $(this).parents('.tabbable').eq(0).find('> .tab-content > [data-idx=' + targetIdx + ']');\r\n\r\n      activate($option, $select);\r\n      activate($target, $target.parent());\r\n      enableFields($target, targetIdx);\r\n    };\r\n\r\n    var tabClicked = function (e) {\r\n      var $a = $('a', $(this));\r\n      var $content = $(this).parents('.tabbable').first()\r\n        .find('.tab-content').first();\r\n      var targetIdx = $(this).index();\r\n      // The `>` here is to prevent activating selectfieldsets inside a tabarray\r\n      var $target = $content.find('> [data-idx=' + targetIdx + ']');\r\n\r\n      e.preventDefault();\r\n      activate($(this), $(this).parent());\r\n      activate($target, $target.parent());\r\n      if ($(this).parent().hasClass('jsonform-alternative')) {\r\n        enableFields($target, targetIdx);\r\n      }\r\n    };\r\n\r\n    tabs.each(function () {\r\n      $(this).delegate('select.nav', 'change', optionSelected);\r\n      $(this).find('select.nav').each(function () {\r\n        $(this).val($(this).find('.active').attr('value'));\r\n        // do not use .attr() as it sometimes unexplicably fails\r\n        var targetIdx = $(this).find('option:selected').get(0).getAttribute('data-idx') ||\r\n          $(this).find('option:selected').attr('value');\r\n        var $target = $(this).parents('.tabbable').eq(0).find('> .tab-content > [data-idx=' + targetIdx + ']');\r\n        enableFields($target, targetIdx);\r\n      });\r\n\r\n      $(this).delegate('ul.nav li', 'click', tabClicked);\r\n      $(this).find('ul.nav li.active').click();\r\n    });\r\n  };\r\n\r\n  //3670-3809\r\n\r\n  /**\r\n   * Highlights errors reported by the JSON schema validator in the document.\r\n   *\r\n   * @function\r\n   * @param {Object} errors List of errors reported by the JSON schema validator\r\n   * @param {Object} options The JSON Form object that describes the form\r\n   *  (unused for the time being, could be useful to store example values or\r\n   *   specific error messages)\r\n   */\r\n  $.fn.jsonFormErrors = function(errors, options) {\r\n    $(\".error\", this).removeClass(\"error\");\r\n    $(\".warning\", this).removeClass(\"warning\");\r\n\r\n    $(\".jsonform-errortext\", this).hide();\r\n    if (!errors) return;\r\n\r\n    var errorSelectors = [];\r\n    for (var i = 0; i < errors.length; i++) {\r\n      // Compute the address of the input field in the form from the URI\r\n      // returned by the JSON schema validator.\r\n      // These URIs typically look like:\r\n      //  urn:uuid:cccc265e-ffdd-4e40-8c97-977f7a512853#/pictures/1/thumbnail\r\n      // What we need from that is the path in the value object:\r\n      //  pictures[1].thumbnail\r\n      // ... and the jQuery-friendly class selector of the input field:\r\n      //  .jsonform-error-pictures\\[1\\]---thumbnail\r\n      var key = errors[i].uri\r\n        .replace(/.*#\\//, '')\r\n        .replace(/\\//g, '.')\r\n        .replace(/\\.([0-9]+)(?=\\.|$)/g, '[$1]');\r\n      var errormarkerclass = \".jsonform-error-\" +\r\n        util.escapeSelector(key.replace(/\\./g,\"---\"));\r\n      errorSelectors.push(errormarkerclass);\r\n\r\n      var errorType = errors[i].type || \"error\";\r\n      $(errormarkerclass, this).addClass(errorType);\r\n      $(errormarkerclass + \" .jsonform-errortext\", this).html(errors[i].message).show();\r\n    }\r\n\r\n    // Look for the first error in the DOM and ensure the element\r\n    // is visible so that the user understands that something went wrong\r\n    errorSelectors = errorSelectors.join(',');\r\n    var firstError = $(errorSelectors).get(0);\r\n    if (firstError && firstError.scrollIntoView) {\r\n      firstError.scrollIntoView(true, {\r\n        behavior: 'smooth'\r\n      });\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Generates the HTML form from the given JSON Form object and renders the form.\r\n   *\r\n   * Main entry point of the library. Defined as a jQuery function that typically\r\n   * needs to be applied to a <form> element in the document.\r\n   *\r\n   * The function handles the following properties for the JSON Form object it\r\n   * receives as parameter:\r\n   * - schema (required): The JSON Schema that describes the form to render\r\n   * - form: The options form layout description, overrides default layout\r\n   * - prefix: String to use to prefix computed IDs. Default is an empty string.\r\n   *  Use this option if JSON Form is used multiple times in an application with\r\n   *  schemas that have overlapping parameter names to avoid running into multiple\r\n   *  IDs issues. Default value is \"jsonform-[counter]\".\r\n   * - transloadit: Transloadit parameters when transloadit is used\r\n   * - validate: Validates form against schema upon submission. Uses the value\r\n   * of the \"validate\" property as validator if it is an object.\r\n   * - displayErrors: Function to call with errors upon form submission.\r\n   *  Default is to render the errors next to the input fields.\r\n   * - submitEvent: Name of the form submission event to bind to.\r\n   *  Default is \"submit\". Set this option to false to avoid event binding.\r\n   * - onSubmit: Callback function to call when form is submitted\r\n   * - onSubmitValid: Callback function to call when form is submitted without\r\n   *  errors.\r\n   *\r\n   * @function\r\n   * @param {Object} options The JSON Form object to use as basis for the form\r\n   */\r\n  $.fn.jsonForm = function(options) {\r\n    var formElt = this;\r\n\r\n    options = langx.defaults({}, options, {submitEvent: 'submit'});\r\n\r\n    var form = new formTree();\r\n    form.initialize(options);\r\n    form.render(formElt.get(0));\r\n\r\n    // TODO: move that to formTree.render\r\n    if (options.transloadit) {\r\n      formElt.append('<input type=\"hidden\" name=\"params\" value=\\'' +\r\n        langx.escapeHTML(JSON.stringify(options.transloadit.params)) +\r\n        '\\'>');\r\n    }\r\n\r\n    // Keep a direct pointer to the JSON schema for form submission purpose\r\n    formElt.data(\"jsonform-tree\", form);\r\n\r\n    if (options.submitEvent) {\r\n      formElt.unbind((options.submitEvent)+'.jsonform');\r\n      formElt.bind((options.submitEvent)+'.jsonform', function(evt) {\r\n        form.submit(evt);\r\n      });\r\n    }\r\n\r\n    // Initialize tabs sections, if any\r\n    initializeTabs(formElt);\r\n\r\n    // Initialize expandable sections, if any\r\n    $('.expandable > div, .expandable > fieldset', formElt).hide();\r\n    formElt.on('click', '.expandable > legend', function () {\r\n      var parent = $(this).parent();\r\n      parent.toggleClass('expanded');\r\n      parent.find('legend').attr(\"aria-expanded\", parent.hasClass(\"expanded\"))\r\n      $('> div', parent).slideToggle(100);\r\n    });\r\n\r\n    return form;\r\n  };\r\n\r\n\r\n  /**\r\n   * Retrieves the structured values object generated from the values\r\n   * entered by the user and the data schema that gave birth to the form.\r\n   *\r\n   * Defined as a jQuery function that typically needs to be applied to\r\n   * a <form> element whose content has previously been generated by a\r\n   * call to \"jsonForm\".\r\n   *\r\n   * Unless explicitly disabled, the values are automatically validated\r\n   * against the constraints expressed in the schema.\r\n   *\r\n   * @function\r\n   * @return {Object} Structured values object that matches the user inputs\r\n   *  and the data schema.\r\n   */\r\n  $.fn.jsonFormValue = function() {\r\n    return getFormValue(this);\r\n  };\r\n\r\n});\r\n\ndefine('skylark-jsonform/get-initial-value',[\r\n  \"skylark-langx\",\r\n  \"./jsonform\",\r\n  \"./util\"\r\n],function(langx,jsonform,util){\r\n  //1758-1881\r\n  /**\r\n   * Returns the initial value that a field identified by its key\r\n   * should take.\r\n   *\r\n   * The \"initial\" value is defined as:\r\n   * 1. the previously submitted value if already submitted\r\n   * 2. the default value defined in the layout of the form\r\n   * 3. the default value defined in the schema\r\n   *\r\n   * The \"value\" returned is intended for rendering purpose,\r\n   * meaning that, for fields that define a titleMap property,\r\n   * the function returns the label, and not the intrinsic value.\r\n   *\r\n   * The function handles values that contains template strings,\r\n   * e.g. {{values.foo[].bar}} or {{idx}}.\r\n   *\r\n   * When the form is a string, the function truncates the resulting string\r\n   * to meet a potential \"maxLength\" constraint defined in the schema, using\r\n   * \"...\" to mark the truncation. Note it does not validate the resulting\r\n   * string against other constraints (e.g. minLength, pattern) as it would\r\n   * be hard to come up with an automated course of action to \"fix\" the value.\r\n   *\r\n   * @function\r\n   * @param {Object} formObject The JSON Form object\r\n   * @param {String} key The generic key path (e.g. foo[].bar.baz[])\r\n   * @param {Array(Number)} arrayPath The array path that identifies\r\n   *  the unique value in the submitted form (e.g. [1, 3])\r\n   * @param {Object} tpldata Template data object\r\n   * @param {Boolean} usePreviousValues true to use previously submitted values\r\n   *  if defined.\r\n   */\r\n  var getInitialValue = function (formObject, key, arrayPath, tpldata, usePreviousValues) {\r\n    var value = null;\r\n\r\n    // Complete template data for template function\r\n    tpldata = tpldata || {};\r\n    tpldata.idx = tpldata.idx ||\r\n      (arrayPath ? arrayPath[arrayPath.length-1] : 1);\r\n    tpldata.value = util.isSet(tpldata.value) ? tpldata.value : '';\r\n    tpldata.getValue = tpldata.getValue || function (key) {\r\n      return getInitialValue(formObject, key, arrayPath, tpldata, usePreviousValues);\r\n    };\r\n\r\n    // Helper function that returns the form element that explicitly\r\n    // references the given key in the schema.\r\n    var getFormElement = function (elements, key) {\r\n      var formElement = null;\r\n      if (!elements || !elements.length) return null;\r\n      util.each(elements, function (elt) {\r\n        if (formElement) return;\r\n        if (elt === key) {\r\n          formElement = { key: elt };\r\n          return;\r\n        }\r\n        if (langx.isString(elt)) return;\r\n        if (elt.key === key) {\r\n          formElement = elt;\r\n        }\r\n        else if (elt.items) {\r\n          formElement = getFormElement(elt.items, key);\r\n        }\r\n      });\r\n      return formElement;\r\n    };\r\n    var formElement = getFormElement(formObject.form || [], key);\r\n    var schemaElement = util.getSchemaKey(formObject.schema.properties, key);\r\n\r\n    if (usePreviousValues && formObject.value) {\r\n      // If values were previously submitted, use them directly if defined\r\n      value = util.getObjKey(formObject.value, util.applyArrayPath(key, arrayPath));\r\n    }\r\n    if (!util.isSet(value)) {\r\n      if (formElement && (typeof formElement['value'] !== 'undefined')) {\r\n        // Extract the definition of the form field associated with\r\n        // the key as it may override the schema's default value\r\n        // (note a \"null\" value overrides a schema default value as well)\r\n        value = formElement['value'];\r\n      }\r\n      else if (schemaElement) {\r\n        // Simply extract the default value from the schema\r\n        if (util.isSet(schemaElement['default'])) {\r\n          value = schemaElement['default'];\r\n        }\r\n      }\r\n      if (value && value.indexOf('{{values.') !== -1) {\r\n        // This label wants to use the value of another input field.\r\n        // Convert that construct into {{getValue(key)}} for\r\n        // Underscore to call the appropriate function of formData\r\n        // when template gets called (note calling a function is not\r\n        // exactly Mustache-friendly but is supported by Underscore).\r\n        value = value.replace(\r\n          /\\{\\{values\\.([^\\}]+)\\}\\}/g,\r\n          '{{getValue(\"$1\")}}');\r\n      }\r\n      if (value) {\r\n        value = langx.template(value, valueTemplateSettings)(tpldata);\r\n      }\r\n    }\r\n\r\n    // TODO: handle on the formElement.options, because user can setup it too.\r\n    // Apply titleMap if needed\r\n    if (isSet(value) && formElement && util.hasOwnProperty(formElement.titleMap, value)) {\r\n      value = langx.template(formElement.titleMap[value], valueTemplateSettings)(tpldata);\r\n    }\r\n\r\n    // Check maximum length of a string\r\n    if (value && _.isString(value) &&\r\n      schemaElement && schemaElement.maxLength) {\r\n      if (value.length > schemaElement.maxLength) {\r\n        // Truncate value to maximum length, adding continuation dots\r\n        value = value.substr(0, schemaElement.maxLength - 1) + '…';\r\n      }\r\n    }\r\n\r\n    if (!util.isSet(value)) {\r\n      return null;\r\n    }\r\n    else {\r\n      return value;\r\n    }\r\n  };\r\n\r\n  return jsonform.getInitialValue = getInitialValue;\r\n\r\n});\r\n\ndefine('skylark-jsonform/main',[\r\n\t\"./jsonform\",\r\n\t\"./element-types\",\r\n\t\"./field-template\",\r\n\t\"./fn\",\r\n\t\"./form-node\",\r\n\t\"./form-tree\",\r\n\t\"./get-form-value\",\r\n\t\"./get-initial-value\",\r\n\t\".\"\r\n],function(jsonform){\r\n\treturn jsonform;\r\n});\ndefine('skylark-jsonform', ['skylark-jsonform/main'], function (main) { return main; });\n\n"]}